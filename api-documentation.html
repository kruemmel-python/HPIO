
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --sidebar-bg: #1e293b;
            --text-color: #e2e8f0;
            --link-color: #38bdf8;
            --link-hover: #7dd3fc;
            --border-color: #334155;
            --h2-color: #67e8f9;
            --h3-color: #a5f3fc;
            --code-bg: #1e293b;
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            flex-shrink: 0;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            height: 100vh;
            overflow-y: auto;
            padding: 1.5rem;
            box-sizing: border-box;
        }
        .sidebar h1 {
            font-size: 1.25rem;
            margin-top: 0;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .sidebar li a {
            display: block;
            padding: 0.5rem 0;
            color: var(--link-color);
            text-decoration: none;
            font-size: 0.875rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.2s;
        }
        .sidebar li a:hover {
            color: var(--link-hover);
        }
        .main-content {
            flex-grow: 1;
            height: 100vh;
            overflow-y: auto;
            padding: 2rem 3rem;
            box-sizing: border-box;
        }
        section {
            padding-top: 2rem;
            margin-top: -2rem;
            margin-bottom: 3rem;
            border-bottom: 1px solid var(--border-color);
        }
        section:last-child {
            border-bottom: none;
        }
        h2 {
            font-size: 1.75rem;
            color: var(--h2-color);
            font-family: monospace;
        }
        h3 {
            font-size: 1.25rem;
            color: var(--h3-color);
            margin-top: 2rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        p { line-height: 1.6; }
        code {
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
        pre {
            background-color: var(--code-bg);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
        }
        pre code {
            padding: 0;
            background: none;
            font-size: 100%;
        }
        .error {
            color: #f87171;
            background-color: #450a0a;
            border: 1px solid #7f1d1d;
            padding: 1rem;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <h1>Project Files</h1>
        <ul>
            <li><a href="#HPIO-main/HPIO_Commands.md">HPIO-main/HPIO_Commands.md</a></li><li><a href="#HPIO-main/README.md">HPIO-main/README.md</a></li><li><a href="#HPIO-main/api-documentation.html">HPIO-main/api-documentation.html</a></li><li><a href="#HPIO-main/diagram.md">HPIO-main/diagram.md</a></li><li><a href="#HPIO-main/hpio.py">HPIO-main/hpio.py</a></li><li><a href="#HPIO-main/hpio_record.py">HPIO-main/hpio_record.py</a></li><li><a href="#HPIO-main/jenseits-des-horizonts-der-hpio-algorithmus-und-se.md">HPIO-main/jenseits-des-horizonts-der-hpio-algorithmus-und-se.md</a></li><li><a href="#HPIO-main/manual.md">HPIO-main/manual.md</a></li><li><a href="#HPIO-main/streamlit_app.py">HPIO-main/streamlit_app.py</a></li>
        </ul>
    </aside>
    <main class="main-content">
        <section id="HPIO-main/HPIO_Commands.md">
    <h2>HPIO-main/HPIO_Commands.md</h2>
    <p>
        Diese Datei enth√§lt eine √úbersicht √ºber die wichtigsten Startbefehle f√ºr den HPIO‚ÄëRecorder, der f√ºr die Optimierung und Videoaufzeichnung von Algorithmen verwendet wird. Die Befehle sind f√ºr die Ausf√ºhrung in PowerShell oder CMD konzipiert und erm√∂glichen die Konfiguration verschiedener Optimierungsfunktionen (Ackley, Rastrigin, Himmelblau) mit unterschiedlichen Modi, Presets und Parametern.
    </p>

    <h3>üß† HPIO ‚Äì Optimierungs- & Videoaufnahme-Kommandos</h3>
    <p>
        Diese Sektion beschreibt die grundlegende Funktionsweise und den Zweck der Befehls√ºbersicht. Sie betont, dass alle Befehle einzeilig sind und direkt in der Kommandozeile ausgef√ºhrt werden k√∂nnen.
    </p>

    <h3>üéØ Ackley (GPU)</h3>
    <p>
        Befehle zur Ausf√ºhrung des HPIO-Recorders mit der Ackley-Funktion, prim√§r unter Verwendung der GPU f√ºr die Berechnung.
    </p>
    <ul>
        <li>
            <h4>1Ô∏è‚É£ Standard GPU‚ÄëModus</h4>
            <p>Standardkonfiguration f√ºr die Ackley-Funktion im GPU-Modus mit Videoaufzeichnung.</p>
            <pre><code class="language-powershell">python hpio_record.py ackley --gpu --video runs/ackley_gpu.mkv --fps 24 --size 1600x900 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>ackley</code>: W√§hlt die Ackley-Funktion.</li>
                <li><code>--gpu</code>: Aktiviert die GPU-Beschleunigung.</li>
                <li><code>--video runs/ackley_gpu.mkv</code>: Speichert das Video unter dem angegebenen Pfad.</li>
                <li><code>--fps 24</code>: Setzt die Bildrate auf 24 Bilder pro Sekunde.</li>
                <li><code>--size 1600x900</code>: Definiert die Videoaufl√∂sung.</li>
                <li><code>--overlay</code>: Zeigt ein Overlay mit Metadaten im Video an.</li>
                <li><code>--report-every 5</code>: Gibt alle 5 Iterationen einen Bericht aus.</li>
            </ul>
        </li>
        <li>
            <h4>2Ô∏è‚É£ Tight‚ÄëVariante (schnelle Konvergenz, weiches Feld)</h4>
            <p>Eine spezielle Konfiguration f√ºr Ackley, die auf schnelle Konvergenz und ein weicheres Feld abzielt.</p>
            <pre><code class="language-powershell">python hpio_record.py ackley --gpu --ackley-tight --video runs/ackley_gpu_tight.mkv --fps 24 --size 1600x900 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>--ackley-tight</code>: Aktiviert das "Tight"-Profil f√ºr Ackley.</li>
            </ul>
        </li>
        <li>
            <h4>3Ô∏è‚É£ Pro‚ÄëPreset (optimierte Sch√§rfe und Phasenf√ºhrung)</h4>
            <p>Verwendet ein vordefiniertes "Pro"-Preset f√ºr Ackley im GPU-Modus, optimiert f√ºr Sch√§rfe und Phasenf√ºhrung.</p>
            <pre><code class="language-powershell">python hpio_record.py ackley --gpu --preset ackley-gpu-pro --video runs/ackley_gpu_pro.mkv --fps 24 --size 1600x900 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>--preset ackley-gpu-pro</code>: L√§dt das spezifische "ackley-gpu-pro"-Preset.</li>
            </ul>
        </li>
        <li>
            <h4>4Ô∏è‚É£ Aggressives Ackley‚ÄëProfil (Flag‚ÄëVariante)</h4>
            <p>Aktiviert ein aggressives Ackley-Profil √ºber ein spezielles Flag.</p>
            <pre><code class="language-powershell">python hpio_record.py ackley --gpu --ackley-pro --video runs/ackley_gpu_aggr.mkv --fps 24 --size 1600x900 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>--ackley-pro</code>: Aktiviert das aggressive "Pro"-Profil f√ºr Ackley.</li>
            </ul>
        </li>
    </ul>

    <h3>üí° Rastrigin (CPU)</h3>
    <p>
        Befehle zur Ausf√ºhrung des HPIO-Recorders mit der Rastrigin-Funktion, prim√§r unter Verwendung der CPU f√ºr die Berechnung.
    </p>
    <ul>
        <li>
            <h4>1Ô∏è‚É£ Standard CPU‚ÄëModus</h4>
            <p>Standardkonfiguration f√ºr die Rastrigin-Funktion im CPU-Modus mit Videoaufzeichnung.</p>
            <pre><code class="language-powershell">python hpio_record.py rastrigin --video runs/rastrigin_std.mp4 --fps 30 --size 1280x720 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>rastrigin</code>: W√§hlt die Rastrigin-Funktion.</li>
                <li><code>--video runs/rastrigin_std.mp4</code>: Speichert das Video unter dem angegebenen Pfad.</li>
                <li><code>--fps 30</code>: Setzt die Bildrate auf 30 Bilder pro Sekunde.</li>
                <li><code>--size 1280x720</code>: Definiert die Videoaufl√∂sung.</li>
            </ul>
        </li>
        <li>
            <h4>2Ô∏è‚É£ CPU‚ÄëPro‚ÄëProfil (bew√§hrt, stabil, pr√§zise)</h4>
            <p>Verwendet ein bew√§hrtes, stabiles und pr√§zises "Pro"-Profil f√ºr Rastrigin im CPU-Modus.</p>
            <pre><code class="language-powershell">python hpio_record.py rastrigin --cpu-pro --video runs/rastrigin_cpu_pro.mp4 --fps 30 --size 1280x720 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>--cpu-pro</code>: Aktiviert das "Pro"-Profil f√ºr CPU-Berechnungen.</li>
            </ul>
        </li>
        <li>
            <h4>3Ô∏è‚É£ CPU‚ÄëPreset‚ÄëProfil (optimiert gegen 1.0‚ÄëRing‚ÄëLock)</h4>
            <p>Verwendet ein spezifisches Preset f√ºr Rastrigin im CPU-Modus, optimiert zur Vermeidung des "1.0-Ring-Lock"-Ph√§nomens.</p>
            <pre><code class="language-powershell">python hpio_record.py rastrigin --preset rastrigin-cpu-pro --video runs/rastrigin_cpu_preset.mp4 --fps 30 --size 1280x720 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>--preset rastrigin-cpu-pro</code>: L√§dt das spezifische "rastrigin-cpu-pro"-Preset.</li>
            </ul>
        </li>
    </ul>

    <h3>üß© Himmelblau (GPU oder CPU)</h3>
    <p>
        Befehle zur Ausf√ºhrung des HPIO-Recorders mit der Himmelblau-Funktion, sowohl im GPU- als auch im CPU-Modus.
    </p>
    <ul>
        <li>
            <h4>1Ô∏è‚É£ Standard GPU‚ÄëModus</h4>
            <p>Standardkonfiguration f√ºr die Himmelblau-Funktion im GPU-Modus mit Videoaufzeichnung.</p>
            <pre><code class="language-powershell">python hpio_record.py himmelblau --gpu --video runs/himmelblau_gpu.mkv --fps 30 --size 1600x900 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>himmelblau</code>: W√§hlt die Himmelblau-Funktion.</li>
                <li><code>--gpu</code>: Aktiviert die GPU-Beschleunigung.</li>
            </ul>
        </li>
        <li>
            <h4>2Ô∏è‚É£ Standard CPU‚ÄëModus</h4>
            <p>Standardkonfiguration f√ºr die Himmelblau-Funktion im CPU-Modus mit Videoaufzeichnung.</p>
            <pre><code class="language-powershell">python hpio_record.py himmelblau --video runs/himmelblau_cpu.mp4 --fps 30 --size 1280x720 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>himmelblau</code>: W√§hlt die Himmelblau-Funktion.</li>
            </ul>
        </li>
    </ul>

    <h3>‚öôÔ∏è Debug‚Äë und Benchmark‚ÄëRuns</h3>
    <p>
        Befehle f√ºr spezielle Anwendungsf√§lle wie Debugging oder das Durchf√ºhren von Benchmarks mit angepassten Parametern.
    </p>
    <ul>
        <li>
            <h4>1Ô∏è‚É£ Minimale Darstellung (ohne Overlay, weniger Frames)</h4>
            <p>Eine Konfiguration f√ºr schnelle L√§ufe mit minimaler visueller Ausgabe, ideal f√ºr Debugging oder schnelle Tests.</p>
            <pre><code class="language-powershell">python hpio_record.py rastrigin --preset rastrigin-cpu-pro --video runs/rastrigin_fast.mp4 --fps 15 --size 1024x576 --viz-freq 3</code></pre>
            <ul>
                <li><code>--fps 15</code>: Reduziert die Bildrate.</li>
                <li><code>--size 1024x576</code>: Reduziert die Videoaufl√∂sung.</li>
                <li><code>--viz-freq 3</code>: Visualisiert nur jede 3. Iteration.</li>
            </ul>
        </li>
        <li>
            <h4>2Ô∏è‚É£ GPU‚ÄëVergleich mit unterschiedlichen Seeds</h4>
            <p>Beispiele f√ºr die Durchf√ºhrung von Vergleichsl√§ufen auf der GPU mit der Ackley-Funktion unter Verwendung unterschiedlicher Zufalls-Seeds, um die Reproduzierbarkeit und Varianz zu testen.</p>
            <pre><code class="language-powershell">python hpio_record.py ackley --gpu --preset ackley-gpu-pro --seed 42 --video runs/ackley_gpu_seed42.mkv --fps 24 --size 1600x900 --overlay --report-every 5
python hpio_record.py ackley --gpu --preset ackley-gpu-pro --seed 99 --video runs/ackley_gpu_seed99.mkv --fps 24 --size 1600x900 --overlay --report-every 5</code></pre>
            <ul>
                <li><code>--seed &lt;number&gt;</code>: Setzt den Zufalls-Seed f√ºr reproduzierbare Ergebnisse.</li>
            </ul>
        </li>
    </ul>

    <h3>üìÅ Ergebnisdateien</h3>
    <p>
        Informationen zu den Speicherorten und Formaten der generierten Videoergebnisse.
    </p>
    <ul>
        <li>
            <p>Alle erzeugten Videos werden automatisch in den Unterordner <code>runs/</code> geschrieben.</p>
        </li>
        <li>
            <p>Die Dateiformate <code>.mp4</code> und <code>.mkv</code> sind mit allen modernen Playern kompatibel.</p>
        </li>
    </ul>

    <p>
        ¬© 2025 ‚Äì HPIO Optimization Suite<br>
        Autor: Ralf Kr√ºmmel ¬∑ Konzept: Hybrid Phase Interaction Optimization (HPIO)
    </p>
</section>
<section id="HPIO-main/README.md">
  <h2>HPIO-main/README.md</h2>

  <p>
    Diese Datei dient als zentrale Einf√ºhrung und √úbersicht √ºber die **HPIO Optimization Suite**. Sie beschreibt das Projekt, seine Kernkomponenten, Funktionen, die Architektur und bietet Anleitungen f√ºr den Schnellstart sowie Verweise auf detailliertere Dokumentationen.
  </p>

  <h3>üß† HPIO Optimization Suite (Einleitung)</h3>
  <p>
    Stellt die **Hybrid Phase Interaction Optimization (HPIO)** als einen hybriden Optimierungsansatz vor, der Agenten-Intelligenz, Feld-Interaktion und algorithmische Eleganz vereint. Es kombiniert biologisch inspirierte Schwarmdynamik mit numerischer Pr√§zision und visualisiert dies in einem interaktiven Kontrollzentrum.
  </p>

  <h3>üöÄ Schnellstart</h3>
  <p>
    Bietet Anweisungen zur schnellen Inbetriebnahme des HPIO-Systems.
  </p>
  <ul>
    <li>
      <h4>Voraussetzungen</h4>
      <p>Listet die notwendigen Python-Pakete auf, die installiert werden m√ºssen.</p>
      <pre><code>pip install numpy pandas streamlit matplotlib imageio
# optional:
pip install pyopencl opencv-python</code></pre>
    </li>
    <li>
      <h4>Start</h4>
      <p>Zeigt den Befehl zum Starten der Streamlit-Anwendung.</p>
      <pre><code>streamlit run streamlit_app.py</code></pre>
    </li>
    <li>
      <h4>Videoaufnahme</h4>
      <p>Gibt ein Beispiel f√ºr die Verwendung des Recorders zur automatisierten Videoaufnahme.</p>
      <pre><code>python hpio_record.py rastrigin --video runs/rastrigin.mp4 --fps 30 --size 1280x720 --overlay</code></pre>
    </li>
  </ul>

  <h3>üß© Hauptkomponenten</h3>
  <p>
    Eine tabellarische √úbersicht der wichtigsten Dateien im Projekt und ihrer jeweiligen Funktionen.
  </p>
  <ul>
    <li><code>hpio.py</code>: Kern des HPIO-Algorithmus (Feld, Agenten, PSO, GA, DE).</li>
    <li><code>streamlit_app.py</code>: Interaktive GUI mit Live-Heatmap, Trail-Tracking und Video-Capture.</li>
    <li><code>hpio_record.py</code>: Recorder f√ºr automatisierte Videoaufnahmen.</li>
    <li><code>HPIO_Commands.md</code>: Befehlsreferenz mit Presets und GPU/CPU-Varianten.</li>
    <li><code>manual.html</code>: Benutzerhandbuch mit Installations- und GUI-Erkl√§rung.</li>
    <li><code>api-documentation.html</code>: Vollst√§ndige API-Dokumentation.</li>
    <li><code>project-whitepaper.html</code>: Architektonischer Leitfaden und Systemdesign.</li>
    <li><code>diagram.svg</code>: System√ºbersicht (Mermaid-Diagramm).</li>
  </ul>

  <h3>üéõÔ∏è Features</h3>
  <p>
    Listet die Hauptmerkmale der HPIO Optimization Suite auf, darunter interaktive Visualisierung, Live-Parameter-Tuning, GPU-Beschleunigung, Video-Export und der Vergleich verschiedener Optimierungsalgorithmen.
  </p>

  <h3>üß≠ Interaktives Kontrollzentrum: Die Streamlit-App (`streamlit_app.py`)</h3>
  <p>
    Detaillierte Beschreibung der Streamlit-Anwendung, ihrer Architektur und der verschiedenen Funktionsbereiche.
  </p>
  <ul>
    <li>
      <h4>Architektur√ºberblick</h4>
      <p>Beschreibt die Kernkomponenten wie `AppState`, `HPIOController`, `Session-Persistence`, `GPU-Erkennung`, `Heatmap-Renderer` und `Video-Engine`.</p>
    </li>
    <li>
      <h4>1) Start / Run ‚Äì Zentrale Steuerung</h4>
      <p>Erl√§utert die Steuerung der Optimierungsl√§ufe, die Auswahl der Zielfunktion, Parameteranpassung und Visualisierung.</p>
    </li>
    <li>
      <h4>2) Parameter ‚Äì Labor f√ºr Feineinstellungen</h4>
      <p>Beschreibt die Konfigurationsm√∂glichkeiten f√ºr Feld, Agenten und erweiterte Steuerungsmechanismen.</p>
    </li>
    <li>
      <h4>3) Algorithmen ‚Äì Vergleichende Benchmark-Suite</h4>
      <p>Stellt die Integration und den Vergleich von Differential Evolution (DE), Particle Swarm Optimization (PSO) und Genetischem Algorithmus (GA) dar.</p>
    </li>
    <li>
      <h4>4) Presets ‚Äì Konfigurationsmanagement</h4>
      <p>Erkl√§rt die Verwaltung von Konfigurations-Presets, deren Import/Export und die Generierung von CLI-Befehlen.</p>
    </li>
    <li>
      <h4>5) Aufnahme & Export ‚Äì Dokumentation & Reproduktion</h4>
      <p>Beschreibt die Funktionen zur Videoaufnahme und zum Export von Artefakten wie Konfigurationen, Trajektorien und Metriken.</p>
    </li>
    <li>
      <h4>6) Experimente ‚Äì Batch- & Benchmark-Framework</h4>
      <p>F√ºhrt die M√∂glichkeiten f√ºr Batch-L√§ufe, Seeds-Sweeps und Parameter-Raster-Experimente auf.</p>
    </li>
    <li>
      <h4>7) Hilfe / Dokumentation</h4>
      <p>Verweist auf ein integriertes Glossar, Troubleshooting-Hinweise und Performance-Tipps.</p>
    </li>
  </ul>

  <h3>üß† Architektur</h3>
  <p>
    Beschreibt die schichtbasierte Architektur des HPIO-Systems, bestehend aus Frontend (Streamlit-GUI), Backend (Algorithmus-Engine) und Recorder-Modul. Ein Mermaid-Diagramm visualisiert die Interaktion dieser Komponenten.
  </p>

  <h3>üìò Dokumentation</h3>
  <p>
    Verweise auf weitere detaillierte Dokumentationsressourcen:
  </p>
  <ul>
    <li><a href="manual.html">Benutzerhandbuch</a>: GUI-Steuerung, Parameter, Workflows.</li>
    <li><a href="api-documentation.html">API-Dokumentation</a>: Funktionen und Klassenreferenz.</li>
    <li><a href="project-whitepaper.html">Whitepaper</a>: Architektur-Philosophie & Systemdesign.</li>
    <li><a href="HPIO_Commands.md">CLI-Befehle</a>: Alle Presets und Aufnahme-Kommandos.</li>
  </ul>

  <h3>üìÇ Projektstruktur</h3>
  <p>
    Eine vereinfachte Darstellung der Verzeichnisstruktur des Projekts.
  </p>

  <h3>üìÑ Lizenz & Autor</h3>
  <p>
    Informationen zum Autor, zur Version und zur Lizenz des Projekts.
  </p>
</section>
<section id="HPIO-main/api-documentation.html">
    <h2>HPIO-main/api-documentation.html</h2>

    <p>
        Diese Datei dient als zentrale technische Dokumentation f√ºr das HPIO-Projekt. Sie ist eine statische HTML-Seite, die die Struktur und Funktionalit√§t der wichtigsten Python-Module des Projekts (<code>hpio.py</code>, <code>hpio_record.py</code>, <code>streamlit_app.py</code>) beschreibt. Die Datei ist so aufgebaut, dass sie eine Navigationsleiste (Sidebar) und einen Hauptinhaltsbereich enth√§lt, in dem die Dokumentation f√ºr jedes Modul in separaten Sektionen pr√§sentiert wird.
    </p>

    <h3>Struktur der Dokumentation</h3>
    <p>
        Die Datei <code>api-documentation.html</code> ist selbst eine HTML-Seite, die die Dokumentation f√ºr andere Dateien enth√§lt. Ihre Hauptkomponenten sind:
    </p>

    <ul>
        <li>
            <p><strong>HTML-Grundger√ºst:</strong></p>
            <p>Standard-HTML5-Struktur mit <code>&lt;!DOCTYPE html&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code> und <code>&lt;body&gt;</code>. Die Sprache ist auf Deutsch (<code>lang="de"</code>) eingestellt.</p>
        </li>
        <li>
            <p><strong>Metadaten:</strong></p>
            <p>Enth√§lt <code>&lt;meta charset="UTF-8"&gt;</code> f√ºr die Zeichenkodierung und <code>&lt;meta name="viewport"&gt;</code> f√ºr responsives Design. Der Titel der Seite ist "Technical Documentation".</p>
        </li>
        <li>
            <p><strong>Inline-CSS (`&lt;style&gt;`):</strong></p>
            <p>Definiert das Styling der gesamten Dokumentationsseite. Dies umfasst:</p>
            <ul>
                <li>Farbvariablen (<code>:root</code>) f√ºr ein dunkles Farbschema.</li>
                <li>Allgemeines Body-Styling (Schriftart, Hintergrund, Textfarbe).</li>
                <li>Styling f√ºr die Sidebar (Navigation).</li>
                <li>Styling f√ºr den Hauptinhaltsbereich.</li>
                <li>Styling f√ºr √úberschriften (<code>h1</code>, <code>h2</code>, <code>h3</code>).</li>
                <li>Styling f√ºr Abs√§tze (<code>p</code>), Code-Bl√∂cke (<code>code</code>, <code>pre</code>) und Listen (<code>ul</code>, <code>li</code>).</li>
                <li>Ein spezielles Styling f√ºr Fehlermeldungen (<code>.error</code>).</li>
            </ul>
        </li>
        <li>
            <p><strong>Sidebar (`&lt;aside class="sidebar"&gt;`):</strong></p>
            <p>Enth√§lt eine Navigationsliste (<code>&lt;ul&gt;</code>) mit Links zu den dokumentierten Dateien. Jeder Link (<code>&lt;a&gt;</code>) verweist auf eine spezifische <code>&lt;section&gt;</code> im Hauptinhaltsbereich mittels Anker-ID.</p>
            <ul>
                <li><code>hpio.py</code></li>
                <li><code>hpio_record.py</code></li>
                <li><code>streamlit_app.py</code></li>
            </ul>
        </li>
        <li>
            <p><strong>Hauptinhaltsbereich (`&lt;main class="main-content"&gt;`):</strong></p>
            <p>Dieser Bereich enth√§lt die eigentliche Dokumentation, aufgeteilt in mehrere <code>&lt;section&gt;</code>-Elemente. Jede Sektion ist einer spezifischen Datei des Projekts gewidmet und enth√§lt detaillierte Beschreibungen von Typ-Aliassen, Konfigurations-Dataclasses, Funktionen, Klassen, deren Methoden und Eigenschaften.</p>
            <ul>
                <li>
                    <p><strong>Sektion f√ºr <code>hpio.py</code> (`&lt;section id="hpio.py"&gt;`):</strong></p>
                    <p>Dokumentiert den Kern des HPIO-Algorithmus, Zielfunktionen, Hilfsfunktionen sowie die Implementierung von Feld und Agenten.</p>
                </li>
                <li>
                    <p><strong>Sektion f√ºr <code>hpio_record.py</code> (`&lt;section id="hpio_record.py"&gt;`):</strong></p>
                    <p>Beschreibt das Modul zur Videoaufzeichnung von HPIO-Optimierungsl√§ufen, einschlie√ülich Hilfsfunktionen und Klassen wie <code>VideoWriter</code>, <code>HPIORecorder</code> und <code>RecordingRunner</code>.</p>
                </li>
                <li>
                    <p><strong>Sektion f√ºr <code>streamlit_app.py</code> (`&lt;section id="streamlit_app.py"&gt;`):</strong></p>
                    <p>Dokumentiert die interaktive Streamlit-Anwendung, ihre Zustandsverwaltung (<code>AppState</code>), den Controller (<code>HPIOController</code>) und die verschiedenen UI-Seiten und Hilfsfunktionen.</p>
                </li>
            </ul>
        </li>
    </ul>

    <h3>Zweck</h3>
    <p>
        Die Datei <code>api-documentation.html</code> dient als benutzerfreundliche und umfassende Referenz f√ºr Entwickler und Interessierte, die die internen Abl√§ufe und die API des HPIO-Projekts verstehen m√∂chten. Durch die klare Strukturierung und die Verwendung von Anker-Links erm√∂glicht sie eine schnelle Navigation zu spezifischen Komponenten und deren Beschreibungen.
    </p>
</section>
<section id="HPIO-main/diagram.md">
    <h2>HPIO-main/diagram.md</h2>
    <p>
        Diese Datei enth√§lt ein Mermaid-Klassendiagramm, das die Architektur einer typischen Webanwendung darstellt. Es visualisiert die Interaktionen und Abh√§ngigkeiten zwischen Frontend- und Backend-Komponenten.
    </p>

    <h3>Architektur√ºbersicht</h3>
    <p>
        Das Diagramm gliedert die Anwendung in zwei Hauptbereiche: das <strong>Frontend</strong> und das <strong>Backend</strong>, und zeigt deren interne Struktur sowie die Kommunikationswege auf.
    </p>

    <h4>Frontend-Komponenten</h4>
    <ul>
        <li>
            <h3><code>App</code></h3>
            <p>
                Der Einstiegspunkt der Anwendung. Die <code>App</code>-Komponente ist der Startpunkt, von dem aus die Anwendung geladen und initialisiert wird.
            </p>
        </li>
        <li>
            <h3><code>Page</code></h3>
            <p>
                Stellt eine einzelne Seite der Anwendung dar. Eine <code>Page</code> setzt sich aus mehreren <code>Component</code>-Instanzen zusammen und ist f√ºr das Abrufen von Daten √ºber den <code>ApiService</code> verantwortlich.
            </p>
        </li>
        <li>
            <h3><code>Component</code></h3>
            <p>
                Kleinere, wiederverwendbare Bausteine, die von <code>Page</code>-Komponenten zusammengesetzt werden, um die Benutzeroberfl√§che zu bilden.
            </p>
        </li>
        <li>
            <h3><code>ApiService</code></h3>
            <p>
                Verantwortlich f√ºr die Kommunikation mit dem Backend. Der <code>ApiService</code> ruft die API √ºber HTTP auf, um Daten zu senden oder zu empfangen.
            </p>
        </li>
    </ul>

    <h4>Backend-Komponenten</h4>
    <ul>
        <li>
            <h3><code>Controller</code></h3>
            <p>
                Die Schnittstelle des Backends, die HTTP-Anfragen entgegennimmt und verarbeitet. Der <code>Controller</code> delegiert die Gesch√§ftslogik an den <code>Service</code>.
                <br/>
                <em>Anmerkung:</em> "Handles HTTP Requests" (Verarbeitet HTTP-Anfragen).
            </p>
        </li>
        <li>
            <h3><code>Service</code></h3>
            <p>
                Enth√§lt die Kern-Gesch√§ftslogik der Anwendung. Der <code>Service</code> interagiert mit dem <code>Repository</code>, um auf Daten zuzugreifen, und operiert auf <code>Model</code>-Objekten.
                <br/>
                <em>Anmerkung:</em> "Contains Business Logic" (Enth√§lt Gesch√§ftslogik).
            </p>
        </li>
        <li>
            <h3><code>Repository</code></h3>
            <p>
                Abstrahiert den Datenzugriff und verwaltet die Persistenz von Daten. Das <code>Repository</code>-Muster trennt die Gesch√§ftslogik von der Datenzugriffslogik und interagiert mit der <code>Database</code>.
                <br/>
                <em>Anmerkung:</em> "Abstracts Data Storage (Repository Pattern)" (Abstrahiert Datenspeicherung (Repository-Muster)).
            </p>
        </li>
        <li>
            <h3><code>Model</code></h3>
            <p>
                Repr√§sentiert die Datenstrukturen und die Gesch√§ftsdom√§ne. <code>Model</code>-Objekte werden vom <code>Service</code> bearbeitet und vom <code>Repository</code> persistiert oder abgerufen.
            </p>
        </li>
        <li>
            <h3><code>Database</code></h3>
            <p>
                Der persistente Speicher f√ºr die Anwendungsdaten. Das <code>Repository</code> interagiert direkt mit der <code>Database</code> (oft √ºber ein ORM oder SQL).
                <br/>
                <em>Anmerkung:</em> "Persistent Storage" (Persistenter Speicher).
            </p>
        </li>
    </ul>

    <h4>Beziehungen und Abh√§ngigkeiten</h4>
    <ul>
        <li><code>App</code> ist der Einstiegspunkt f√ºr <code>Page</code>-Komponenten.</li>
        <li>Eine <code>Page</code> setzt sich aus <code>Component</code>-Instanzen zusammen.</li>
        <li>Eine <code>Page</code> ruft Daten √ºber den <code>ApiService</code> ab.</li>
        <li>Der <code>ApiService</code> ruft die API des <code>Controller</code> auf (HTTP).</li>
        <li>Der <code>Controller</code> delegiert die Gesch√§ftslogik an den <code>Service</code>.</li>
        <li>Der <code>Service</code> verwaltet den Datenzugriff √ºber das <code>Repository</code> und operiert auf <code>Model</code>-Objekten.</li>
        <li>Das <code>Repository</code> persistiert/ruft <code>Model</code>-Objekte ab und interagiert mit der <code>Database</code>.</li>
        <li>Es bestehen Abh√§ngigkeiten (gestrichelte Linien) zwischen <code>Controller</code> und <code>Service</code>, <code>Service</code> und <code>Repository</code>, <code>Service</code> und <code>Model</code>, sowie <code>Repository</code> und <code>Model</code>, was auf Injektion oder lose Kopplung hindeutet.</li>
    </ul>
</section>
<section id="HPIO-main/hpio.py">
    <h2>HPIO-main/hpio.py</h2>

    <p>Dieses Modul implementiert den Kern des HPIO-Algorithmus (Hybrid Particle-Inspired Optimization) sowie verschiedene Hilfsfunktionen, Zielfunktionen und alternative Optimierungsalgorithmen (Differential Evolution, Particle Swarm Optimization, Genetic Algorithm). Es definiert Konfigurations-Dataclasses, die den Aufbau des Feldes und das Verhalten der Agenten steuern.</p>

    <h3>Typ-Aliase</h3>
    <ul>
        <li>
            <code>AlgorithmName</code>:
            <p>Ein Literal-Typ, der die unterst√ºtzten Algorithmusnamen definiert.</p>
            <ul>
                <li>M√∂gliche Werte: <code>"hpio"</code>, <code>"de"</code>, <code>"pso"</code>, <code>"ga"</code></li>
            </ul>
        </li>
        <li>
            <code>ObjectiveName</code>:
            <p>Ein Literal-Typ, der die Namen der implementierten Zielfunktionen definiert.</p>
            <ul>
                <li>M√∂gliche Werte: <code>"rastrigin"</code>, <code>"ackley"</code>, <code>"himmelblau"</code></li>
            </ul>
        </li>
    </ul>

    <h3>Konfigurations-Dataclasses</h3>

    <h4><code id="FieldParams">class FieldParams</code></h4>
    <p>Dataclass zur Konfiguration der Parameter des Feldes.</p>
    <ul>
        <li>
            <code>grid_size: tuple[int, int] = (160, 160)</code>:
            <p>Gr√∂√üe des Feldes in Pixeln (Breite, H√∂he).</p>
        </li>
        <li>
            <code>relax_alpha: float = 0.25</code>:
            <p>Relaxationsfaktor f√ºr die Feldaktualisierung.</p>
        </li>
        <li>
            <code>evap: float = 0.04</code>:
            <p>Evaporationsrate des Feldes pro Iteration.</p>
        </li>
        <li>
            <code>kernel_sigma: float = 1.6</code>:
            <p>Standardabweichung (Sigma) des Gau√üschen Kernels f√ºr die Feldgl√§ttung.</p>
        </li>
    </ul>

    <h4><code id="AgentParams">class AgentParams</code></h4>
    <p>Dataclass zur Konfiguration der Parameter der Agenten.</p>
    <ul>
        <li>
            <code>count: int = 64</code>:
            <p>Anzahl der Agenten im Schwarm.</p>
        </li>
        <li>
            <code>step: float = 0.35</code>:
            <p>Basis-Schrittgr√∂√üe der Agenten.</p>
        </li>
        <li>
            <code>curiosity: float = 0.45</code>:
            <p>Faktor f√ºr die zuf√§llige Neugier-Komponente der Agentenbewegung.</p>
        </li>
        <li>
            <code>momentum: float = 0.65</code>:
            <p>Momentum-Faktor f√ºr die Agentengeschwindigkeit.</p>
        </li>
        <li>
            <code>deposit_sigma: float = 1.6</code>:
            <p>Breite der Feldablage in Grid-Pixeln (œÉ). <code>0</code> bedeutet Punktablage.</p>
        </li>
        <li>
            <code>coherence_gain: float = 0.0</code>:
            <p>Koh√§renz in Richtung des globalen Bestwerts (0..~1). <code>0</code> schaltet diese Funktion aus.</p>
        </li>
    </ul>

    <h4><code id="HPIOConfig">class HPIOConfig</code></h4>
    <p>Haupt-Dataclass zur Konfiguration des HPIO-Algorithmus.</p>
    <ul>
        <li>
            <code>objective: ObjectiveName</code>:
            <p>Die zu optimierende Zielfunktion.</p>
        </li>
        <li>
            <code>algorithm: AlgorithmName = "hpio"</code>:
            <p>Der zu verwendende Algorithmus (standardm√§√üig HPIO).</p>
        </li>
        <li>
            <code>iters: int = 420</code>:
            <p>Anzahl der Iterationen des Optimierungsalgorithmus.</p>
        </li>
        <li>
            <code>seed: int = 123</code>:
            <p>Seed f√ºr den Zufallszahlengenerator zur Reproduzierbarkeit.</p>
        </li>
        <li>
            <code>use_gpu: bool = False</code>:
            <p>Gibt an, ob die GPU verwendet werden soll (aktuell nicht implementiert).</p>
        </li>
        <li>
            <code>visualize: bool = False</code>:
            <p>Gibt an, ob eine Visualisierung erfolgen soll (aktuell nicht implementiert).</p>
        </li>
        <li>
            <code>bounds: tuple[tuple[float, float], tuple[float, float]] = ((-5.5, 5.5), (-5.5, 5.5))</code>:
            <p>Definiert die Suchgrenzen f√ºr die X- und Y-Achse.</p>
        </li>
        <li>
            <code>report_every: int = 20</code>:
            <p>Intervall, in dem Fortschritt berichtet wird (aktuell nicht verwendet).</p>
        </li>
        <li>
            <code>anneal_step_from: float = 1.0</code>:
            <p>Startwert f√ºr die Annealing-Skalierung der Schrittgr√∂√üe.</p>
        </li>
        <li>
            <code>anneal_step_to: float = 0.2</code>:
            <p>Endwert f√ºr die Annealing-Skalierung der Schrittgr√∂√üe.</p>
        </li>
        <li>
            <code>anneal_curiosity_from: float = 1.0</code>:
            <p>Startwert f√ºr die Annealing-Skalierung der Neugier.</p>
        </li>
        <li>
            <code>anneal_curiosity_to: float = 0.25</code>:
            <p>Endwert f√ºr die Annealing-Skalierung der Neugier.</p>
        </li>
        <li>
            <code>early_patience: int = 90</code>:
            <p>Anzahl der Iterationen ohne Verbesserung, bevor Early Stopping eintritt.</p>
        </li>
        <li>
            <code>early_tol: float = 1e-4</code>:
            <p>Toleranzschwelle f√ºr die Erkennung einer Verbesserung beim Early Stopping.</p>
        </li>
        <li>
            <code>polish_h: float = 1e-3</code>:
            <p>Schrittgr√∂√üe f√ºr die numerische Ableitung bei der lokalen quadratischen Verfeinerung.</p>
        </li>
        <li>
            <code>w_intensity: float = 1.0</code>:
            <p>Gewicht f√ºr den Intensit√§tsanteil der Ablage.</p>
        </li>
        <li>
            <code>w_phase: float = 0.0</code>:
            <p>Gewicht f√ºr den Phasenanteil der Ablage.</p>
        </li>
        <li>
            <code>phase_span_pi: float = 2.0</code>:
            <p>Phasen-Spannweite in Einheiten von œÄ (z. B. 2.4 ‚Üí 2.4œÄ).</p>
        </li>
        <li>
            <code>field: FieldParams = dc.field(default_factory=FieldParams)</code>:
            <p>Instanz der Feldparameter.</p>
        </li>
        <li>
            <code>agent: AgentParams = dc.field(default_factory=AgentParams)</code>:
            <p>Instanz der Agentenparameter.</p>
        </li>
    </ul>

    <h3>Zielfunktionen</h3>

    <h4><code id="rastrigin_fn">def rastrigin_fn(x: np.ndarray) -> float</code></h4>
    <p>Implementiert die Rastrigin-Zielfunktion.</p>
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>x</code> (<code>np.ndarray</code>): Ein 2D-Array der Koordinaten.</li>
            </ul>
        </li>
        <li>
            <strong>R√ºckgabewert:</strong>
            <ul>
                <li><code>float</code>: Der Funktionswert an der gegebenen Position.</li>
            </ul>
        </li>
    </ul>

    <h4><code id="ackley_fn">def ackley_fn(x: np.ndarray) -> float</code></h4>
    <p>Implementiert die Ackley-Zielfunktion.</p>
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>x</code> (<code>np.ndarray</code>): Ein 2D-Array der Koordinaten.</li>
            </ul>
        </li>
        <li>
            <strong>R√ºckgabewert:</strong>
            <ul>
                <li><code>float</code>: Der Funktionswert an der gegebenen Position.</li>
            </ul>
        </li>
    </ul>

    <h4><code id="himmelblau_fn">def himmelblau_fn(x: np.ndarray) -> float</code></h4>
    <p>Implementiert die Himmelblau-Zielfunktion.</p>
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>x</code> (<code>np.ndarray</code>): Ein 2D-Array der Koordinaten.</li>
            </ul>
        </li>
        <li>
            <strong>R√ºckgabewert:</strong>
            <ul>
                <li><code>float</code>: Der Funktionswert an der gegebenen Position.</li>
            </ul>
        </li>
    </ul>

    <h4><code id="OBJECTIVES">OBJECTIVES: dict[ObjectiveName, Callable[[np.ndarray], float]]</code></h4>
    <p>Ein Dictionary, das die Namen der Zielfunktionen ihren entsprechenden Implementierungen zuordnet.</p>

    <h3>Hilfsfunktionen</h3>

    <h4><code id="_gaussian_kernel_1d">def _gaussian_kernel_1d(sigma: float) -> np.ndarray</code></h4>
    <p>Erzeugt einen 1D-Gau√üschen Kernel.</p>
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>sigma</code> (<code>float</code>): Die Standardabweichung des Gau√üschen Kernels.</li>
            </ul>
        </li>
        <li>
            <strong>R√ºckgabewert:</strong>
            <ul>
                <li><code>np.ndarray</code>: Der 1D-Gau√üsche Kernel.</li>
            </ul>
        </li>
    </ul>

    <h4><code id="_apply_conv1d">def _apply_conv1d(arr: np.ndarray, kernel: np.ndarray, axis: int) -> np.ndarray</code></h4>
    <p>Wendet einen 1D-Faltungskernel entlang einer bestimmten Achse eines 2D-Arrays an.</p>
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>arr</code> (<code>np.ndarray</code>): Das Eingabearray.</li>
                <li><code>kernel</code> (<code>np.ndarray</code>): Der 1D-Faltungskernel.</li>
                <li><code>axis</code> (<code>int</code>): Die Achse, entlang der die Faltung angewendet werden soll.</li>
            </ul>
        </li>
        <li>
            <strong>R√ºckgabewert:</strong>
            <ul>
                <li><code>np.ndarray</code>: Das gefaltete Array.</li>
            </ul>
        </li>
    </ul>

    <h4><code id="_stamp_gaussian">def _stamp_gaussian(grid: np.ndarray, cx: int, cy: int, sigma: float, amount: float) -> None</code></h4>
    <p>Addiert einen 2D-Gau√üschen Stempel um <code>(cx, cy)</code> zu einem Gitter. Die Summe der Maske wird auf <code>'amount'</code> normiert.</p>
    <ul>
        <li>
            <strong>Parameter:</strong>
            <ul>
                <li><code>grid</code> (<code>np.ndarray</code>): Das Gitter, zu dem der Gau√üsche Stempel hinzugef√ºgt werden soll.</li>
                <li><code>cx</code> (<code>int</code>): Die X-Koordinate des Zentrums des Stempels.</li>
                <li><code>cy</code> (<code>int</code>): Die Y-Koordinate des Zentrums des Stempels.</li>
                <li><code>sigma</code> (<code>float</code>): Die Standardabweichung des Gau√üschen Stempels in Pixeln.</li>
                <li><code>amount</code> (<code>float</code>): Der Gesamtbetrag, der durch den Gau√üschen Stempel hinzugef√ºgt werden soll.</li>
            </ul>
        </li>
        <li>
            <strong>R√ºckgabewert:</strong>
            <ul>
                <li><code>None</code></li>
            </ul>
        </li>
    </ul>

    <h3>Feld- und Agentenimplementierung</h3>

    <h4><code id="AgentState">class AgentState</code></h4>
    <p>Dataclass zur Speicherung des Zustands eines einzelnen Agenten.</p>
    <ul>
        <li>
            <code>pos: np.ndarray</code>:
            <p>Aktuelle Position des Agenten.</p>
        </li>
        <li>
            <code>vel: np.ndarray</code>:
            <p>Aktuelle Geschwindigkeit des Agenten.</p>
        </li>
        <li>
            <code>best_pos: np.ndarray</code>:
            <p>Beste bisher gefundene Position des Agenten.</p>
        </li>
        <li>
            <code>best_val: float</code>:
            <p>Bester bisher gefundener Funktionswert des Agenten.</p>
        </li>
    </ul>

    <h4><code id="Field">class Field</code></h4>
    <p>Repr√§sentiert das Feld, auf dem die Agenten interagieren und Ablagerungen vornehmen.</p>
    <ul>
        <li>
            <strong>Konstruktor:</strong> <code>__init__(self, params: FieldParams, bounds: tuple[Tuple[float, float], Tuple[float, float]])</code>
            <ul>
                <li>
                    <strong>Parameter:</strong>
                    <ul>
                        <li><code>params</code> (<code>FieldParams</code>): Die Konfigurationsparameter f√ºr das Feld.</li>
                        <li><code>bounds</code> (<code>tuple[Tuple[float, float], Tuple[float, float]]</code>): Die Suchgrenzen der Weltkoordinaten.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code id="Field.world_to_grid">def world_to_grid(self, pos: np.ndarray) -> tuple[int, int]</code>
            <p>Konvertiert Weltkoordinaten in Gitterkoordinaten (ganzzahlig).</p>
            <ul>
                <li>
                    <strong>Parameter:</strong>
                    <ul>
                        <li><code>pos</code> (<code>np.ndarray</code>): Die Position in Weltkoordinaten.</li>
                    </ul>
                </li>
                <li>
                    <strong>R√ºckgabewert:</strong>
                    <ul>
                        <li><code>tuple[int, int]</code>: Die Position in Gitterkoordinaten.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code id="Field.world_to_grid_float">def world_to_grid_float(self, pos: np.ndarray) -> tuple[float, float]</code>
            <p>Konvertiert Weltkoordinaten in Gitterkoordinaten (Gleitkomma).</p>
            <ul>
                <li>
                    <strong>Parameter:</strong>
                    <ul>
                        <li><code>pos</code> (<code>np.ndarray</code>): Die Position in Weltkoordinaten.</li>
                    </ul>
                </li>
                <li>
                    <strong>R√ºckgabewert:</strong>
                    <ul>
                        <li><code>tuple[float, float]</code>: Die Position in Gitterkoordinaten als Gleitkommazahlen.</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code id="Field.deposit">def deposit(self, pos: np.ndarray, amount: float, sigma_px: float = 0.0) -> None</code>
            <p>Nimmt eine Ablage im Feld vor. Wenn <code>sigma_px > 0</code>, wird ein 2D-Gauss-Stempel verwendet, sonst eine Punktablage.</p>
            <ul>
                <li>
                    <strong>Parameter:</strong>
                    <ul>
                        <li><code>pos</code> (<code>np.ndarray</code>): Die Weltkoordinaten der Ablage.</li>
                        <li><code>amount</code> (<code>float</code>): Der Betrag der Ablage.</li>
                        <li><code>sigma_px</code> (<code>float</code>, optional): Die Standardabweichung des Gau√üschen Stempels in Pixeln. Standard ist <code>0.0</code> (Punktablage).</li>
                    </ul>
                </li>
                <li>
                    <strong>R√ºckgabewert:</strong>
                    <ul>
                        <li><code>None</code></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <code id="Field.sample_gradient">def sample_gradient(self, pos: np.ndarray) -> np.ndarray</code>
            <p>Berechnet den Gradienten des Feldes an einer gegebenen Weltposition.</p>
            <ul>
                <li>
                    <strong>Parameter:</strong>
                    <ul>
                        <li><code>pos</code> (<code>np.ndarray</code>): Die Weltkoordinaten, an denen der Gradient abgetastet werden soll.</li>
                    </ul>
                </li>
                <li>
                    <strong>R√ºckgabewert:</strong>
<section id="HPIO-main/hpio_record.py">
    <h2>HPIO-main/hpio_record.py</h2>
    <p>
        Dieses Skript, <code>hpio_record.py</code>, dient der Videoaufzeichnung (MP4/MKV) der HPIO-Optimierung.
        Es ist eine robuste Version, die die lokale <code>hpio.py</code> explizit via <code>importlib.util</code> l√§dt,
        Komposition statt Vererbung nutzt und die HPIO.run-Schleife nachbildet, um pro Iteration Frames zu rendern.
    </p>
    <p>
        <strong>Aufrufbeispiele:</strong>
    </p>
    <pre><code>python hpio_record.py rastrigin --video runs/rastrigin.mp4 --fps 30 --size 1280x720
python hpio_record.py ackley --gpu --video runs/ackley_gpu.mkv --fps 24 --size 1600x900
python hpio_record.py himmelblau --video runs/himmelblau.mp4 --viz-freq 2</code></pre>

    <h3>Typ-Alias: <code>ObjectiveName</code></h3>
    <p>
        Definiert die unterst√ºtzten Namen der Zielfunktionen als Literal-Typ.
    </p>
    <ul>
        <li><strong>Typ:</strong> <code>Literal["rastrigin", "ackley", "himmelblau"]</code></li>
    </ul>

    <h3>Funktion: <code>load_local_hpio()</code></h3>
    <p>
        L√§dt die lokale <code>hpio.py</code>-Datei sicher aus demselben Ordner wie dieses Skript.
        Dies gew√§hrleistet, dass die korrekte Version des HPIO-Moduls verwendet wird, auch wenn andere Versionen im Python-Pfad existieren.
    </p>
    <ul>
        <li><strong>Zweck:</strong> Importiert das HPIO-Modul dynamisch.</li>
        <li><strong>Parameter:</strong> Keine.</li>
        <li><strong>R√ºckgabe:</strong> Das geladene HPIO-Modul.</li>
        <li><strong>Fehlerbehandlung:</strong> Beendet das Programm, wenn <code>hpio.py</code> nicht gefunden oder nicht geladen werden kann.</li>
    </ul>

    <h3>Funktion: <code>clamp(x: float, lo: float, hi: float) -> float</code></h3>
    <p>
        Begrenzt einen Wert <code>x</code> auf einen Bereich zwischen <code>lo</code> (Minimum) und <code>hi</code> (Maximum).
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>x</code> (float): Der zu begrenzende Wert.</li>
                <li><code>lo</code> (float): Die untere Grenze.</li>
                <li><code>hi</code> (float): Die obere Grenze.</li>
            </ul>
        </li>
        <li><strong>R√ºckgabe:</strong> (float) Der begrenzte Wert.</li>
    </ul>

    <h3>Funktion: <code>lerp(a: float, b: float, t: float) -> float</code></h3>
    <p>
        F√ºhrt eine lineare Interpolation zwischen zwei Werten <code>a</code> und <code>b</code> basierend auf einem Faktor <code>t</code> durch.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>a</code> (float): Der Startwert.</li>
                <li><code>b</code> (float): Der Endwert.</li>
                <li><code>t</code> (float): Der Interpolationsfaktor (0.0 f√ºr <code>a</code>, 1.0 f√ºr <code>b</code>).</li>
            </ul>
        </li>
        <li><strong>R√ºckgabe:</strong> (float) Der interpolierte Wert.</li>
    </ul>

    <h3>Funktion: <code>smoothstep(t: float) -> float</code></h3>
    <p>
        Berechnet eine Smoothstep-Funktion, die einen Wert <code>t</code> sanft von 0 auf 1 √ºberblendet.
        Der Wert <code>t</code> wird zuerst auf den Bereich [0, 1] geklemmt.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>t</code> (float): Der Eingabewert, typischerweise zwischen 0 und 1.</li>
            </ul>
        </li>
        <li><strong>R√ºckgabe:</strong> (float) Der gegl√§ttete Wert.</li>
    </ul>

    <h3>Klasse: <code>VideoWriter</code></h3>
    <p>
        Eine Klasse zum Schreiben von Videodateien. Sie versucht, FFmpeg (√ºber Matplotlib) als Backend zu verwenden und f√§llt auf OpenCV zur√ºck, falls FFmpeg nicht verf√ºgbar ist.
    </p>
    <h4>Konstruktor: <code>__init__(self, fname: str, fps: int, width: int, height: int)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> Initialisiert den VideoWriter und versucht, ein geeignetes Backend (FFmpeg oder OpenCV) zu konfigurieren.</li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>fname</code> (str): Der Dateiname f√ºr das Ausgabevideo.</li>
                <li><code>fps</code> (int): Frames pro Sekunde.</li>
                <li><code>width</code> (int): Breite des Videos in Pixeln.</li>
                <li><code>height</code> (int): H√∂he des Videos in Pixeln.</li>
            </ul>
        </li>
        <li><strong>Fehlerbehandlung:</strong> L√∂st eine <code>RuntimeError</code> aus, wenn kein Video-Backend verf√ºgbar ist.</li>
    </ul>
    <h4>Eigenschaft: <code>fig</code></h4>
    <ul>
        <li><strong>Zweck:</strong> Gibt die Matplotlib-Figur zur√ºck, wenn das FFmpeg-Backend verwendet wird, ansonsten <code>None</code>.</li>
        <li><strong>R√ºckgabe:</strong> (matplotlib.figure.Figure | None) Die Matplotlib-Figur.</li>
    </ul>
    <h4>Methode: <code>add_frame_from_figure(self)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> F√ºgt einen Frame aus der aktuellen Matplotlib-Figur hinzu.</li>
        <li><strong>Voraussetzung:</strong> Nur f√ºr das FFmpeg-Backend verf√ºgbar.</li>
        <li><strong>Fehlerbehandlung:</strong> L√∂st eine <code>RuntimeError</code> aus, wenn das falsche Backend verwendet wird.</li>
    </ul>
    <h4>Methode: <code>add_frame_from_rgb(self, rgb: np.ndarray)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> F√ºgt einen Frame aus einem RGB-NumPy-Array hinzu.</li>
        <li><strong>Voraussetzung:</strong> Nur f√ºr das OpenCV-Backend verf√ºgbar.</li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>rgb</code> (np.ndarray): Ein NumPy-Array im RGB-Format (H√∂he, Breite, 3).</li>
            </ul>
        </li>
        <li><strong>Fehlerbehandlung:</strong> L√∂st eine <code>RuntimeError</code> aus, wenn das falsche Backend verwendet wird.</li>
    </ul>
    <h4>Methode: <code>close(self)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> Schlie√üt den VideoWriter und gibt Ressourcen frei.</li>
    </ul>

    <h3>Klasse: <code>HPIORecorder</code></h3>
    <p>
        Verwaltet die Benutzeroberfl√§che f√ºr die HPIO-Aufzeichnung, die aus einer Heatmap (links) und einer Konsole (rechts) besteht.
        Sie nutzt Matplotlib zur Darstellung und integriert sich mit dem <code>VideoWriter</code>.
    </p>
    <h4>Konstruktor: <code>__init__(self, writer: VideoWriter, grid_size: tuple[int,int], text_lines: int = 28)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> Initialisiert den Recorder mit einem VideoWriter und konfiguriert die Matplotlib-Figur f√ºr die Darstellung.</li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>writer</code> (VideoWriter): Eine Instanz des <code>VideoWriter</code> zum Speichern der Frames.</li>
                <li><code>grid_size</code> (tuple[int,int]): Die Gr√∂√üe des HPIO-Feldes (Breite, H√∂he).</li>
                <li><code>text_lines</code> (int, optional): Die maximale Anzahl der angezeigten Log-Zeilen in der Konsole. Standard ist 28.</li>
            </ul>
        </li>
    </ul>
    <h4>Methode: <code>log(self, line: str)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> F√ºgt eine Zeile zum internen Log des Recorders hinzu, die sp√§ter in der Konsolenansicht angezeigt wird.</li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>line</code> (str): Die hinzuzuf√ºgende Log-Nachricht.</li>
            </ul>
        </li>
    </ul>
    <h4>Methode: <code>frame(self, field_phi: np.ndarray, agents_px: np.ndarray, *, title: str | None = None)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> Aktualisiert die linke (Heatmap) und rechte (Konsole) Ansicht und f√ºgt den resultierenden Frame dem VideoWriter hinzu.</li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>field_phi</code> (np.ndarray): Das komplexe Feld Œ¶ des HPIO-Algorithmus.</li>
                <li><code>agents_px</code> (np.ndarray): Die Positionen der Agenten in Pixelkoordinaten.</li>
                <li><code>title</code> (str | None, optional): Ein optionaler Titel f√ºr die linke Ansicht.</li>
            </ul>
        </li>
    </ul>

    <h3>Klasse: <code>RecordingRunner</code></h3>
    <p>
        Diese Klasse implementiert die Hauptoptimierungsschleife des HPIO-Algorithmus, um die Iterationen f√ºr die Videoaufzeichnung zu steuern.
        Sie nutzt Komposition, indem sie eine Instanz von <code>hpio.HPIO</code> direkt verwendet.
    </p>
    <h4>Konstruktor: <code>__init__(self, cfg: "hpio.HPIOConfig", recorder: HPIORecorder, viz_every: int = 1)</code></h4>
    <ul>
        <li><strong>Zweck:</strong> Initialisiert den Runner mit einer HPIO-Konfiguration und einem Recorder.</li>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>cfg</code> (hpio.HPIOConfig): Die Konfiguration f√ºr den HPIO-Algorithmus.</li>
                <li><code>recorder</code> (HPIORecorder): Eine Instanz des <code>HPIORecorder</code> zur Visualisierung.</li>
                <li><code>viz_every</code> (int, optional): Gibt an, wie oft (jede n-te Iteration) ein Frame aufgezeichnet werden soll. Standard ist 1.</li>
            </ul>
        </li>
    </ul>
    <h4>Methode: <code>run(self) -> tuple[np.ndarray, float]</code></h4>
    <ul>
        <li><strong>Zweck:</strong> F√ºhrt die HPIO-Optimierungsschleife aus, aktualisiert den Recorder in bestimmten Intervallen und implementiert Early-Stopping sowie einen abschlie√üenden lokalen Polish-Schritt.</li>
        <li><strong>Parameter:</strong> Keine.</li>
        <li><strong>R√ºckgabe:</strong> (tuple[np.ndarray, float]) Die beste gefundene Position und der zugeh√∂rige beste Wert.</li>
    </ul>

    <h3>Funktion: <code>parse_size(s: str) -> tuple[int, int]</code></h3>
    <p>
        Eine Hilfsfunktion zum Parsen einer Zeichenkette im Format "WIDTHxHEIGHT" in ein Tupel von Integer-Werten.
    </p>
    <ul>
        <li><strong>Parameter:</strong>
            <ul>
                <li><code>s</code> (str): Die Eingabezeichenkette, z.B. "1280x720".</li>
            </ul>
        </li>
        <li><strong>R√ºckgabe:</strong> (tuple[int, int]) Ein Tupel (Breite, H√∂he).</li>
        <li><strong>Fehlerbehandlung:</strong> L√∂st einen <code>argparse.ArgumentTypeError</code> aus, wenn das Format ung√ºltig ist.</li>
    </ul>

    <h3>Funktion: <code>main()</code></h3>
    <p>
        Die Hauptfunktion des Skripts. Sie parst Kommandozeilenargumente, initialisiert den VideoWriter und den HPIO-Recorder,
        wendet Konfigurations-Presets an und startet den <code>RecordingRunner</code>.
    </p>
    <ul>
        <li><strong>Zweck:</strong> Steuert den gesamten Ablauf der Videoaufzeichnung der HPIO-Optimierung.</li>
        <li><strong>Parameter:</strong> Keine.</li>
        <li><strong>R√ºckgabe:</strong> Keine.</li>
        <li><strong>Kommandozeilenargumente:</strong>
            <ul>
                <li><code>objective</code>: Die zu optimierende Zielfunktion (rastrigin, ackley, himmelblau).</li>
                <li><code>--gpu</code>: Aktiviert GPU-Relaxation (PyOpenCL).</li>
                <li><code>--video</code>: Pfad zur Ausgabevideodatei (erforderlich).</li>
                <li><code>--fps</code>: Frames pro Sekunde (Standard: 30).</li>
                <li><code>--size</code>: Videogr√∂√üe im Format WIDTHxHEIGHT (Standard: 1280x720).</li>
                <li><code>--viz-freq</code>: Jede n-te Iteration als Frame aufzeichnen (Standard: 1).</li>
                <li><code>--seed</code>: Zufalls-Seed (Standard: 123).</li>
                <li><code>--report-every</code>: Alle n Iterationen loggen (√ºberschreibt cfg.report_every).</li>
                <li><code>--overlay</code>: Zeigt Iteration & Bestwert live im Plot an.</li>
                <li><code>--ackley-tight</code>: Aggressives Tuning f√ºr Ackley (GPU empfohlen).</li>
                <li><code>--ackley-pro</code>: Aggressives, bew√§hrtes Ackley-Profil (GPU empfohlen).</li>
                <li><code>--cpu-pro</code>: Bew√§hrtes CPU-Profil f√ºr alle Objectives.</li>
                <li><code>--preset</code>: Voreinstellung f√ºr bew√§hrte Konvergenz (√ºberschreibt einzelne Flags), z.B. "ackley-gpu-pro", "rastrigin-cpu-pro".</li>
            </ul>
        </li>
    </ul>
</section>
<section id="HPIO-main/jenseits-des-horizonts-der-hpio-algorithmus-und-se.md">
    <h2>HPIO-main/jenseits-des-horizonts-der-hpio-algorithmus-und-se.md</h2>

    <p>
        Dieser Artikel, verfasst von Ralf Kr√ºmmel, dem Entwickler, bietet eine tiefgehende Erkundung des **Hybrid Particle‚ÄëInspired Optimizer (HPIO)**. Er beschreibt die architektonischen Prinzipien, die dem System zugrunde liegen, von der Kernimplementierung des Algorithmus √ºber die Visualisierung bis hin zur interaktiven Benutzeroberfl√§che und den √ºbergeordneten Softwarearchitekturkonzepten. Das Dokument dient als umfassende technische Dokumentation und Einf√ºhrung in das HPIO-Projekt.
    </p>

    <h3>1. Das Herzst√ºck der Optimierung: Der HPIO‚ÄëAlgorithmus (<code>hpio.py</code>)</h3>
    <p>
        Dieses Modul ist die zentrale Implementierung des HPIO-Optimierungsalgorithmus. Es wurde entwickelt, um globale Minima in komplexen, nicht-konvexen Zielfunktionen zu finden, inspiriert von der kollektiven Intelligenz nat√ºrlicher Schw√§rme. Es enth√§lt auch Implementierungen alternativer Optimierungsalgorithmen wie Differential Evolution (DE), Particle Swarm Optimization (PSO) und Genetische Algorithmen (GA).
    </p>
    <h4>Schl√ºsselkomponenten:</h4>
    <ul>
        <li>
            <code>FieldParams</code>:
            <p>
                <strong>Zweck:</strong> Definiert Parameter f√ºr das Optimierungsfeld.
            </p>
            <ul>
                <li><code>grid_size</code>: Gr√∂√üe des Gitters (z.B. <code>(160, 160)</code> Pixel).</li>
                <li><code>relax_alpha</code>: Relaxationsfaktor.</li>
                <li><code>evap</code>: Verdampfungsrate.</li>
                <li><code>kernel_sigma</code>: Standardabweichung des Gau√üschen Kernels.</li>
            </ul>
        </li>
        <li>
            <code>AgentParams</code>:
            <p>
                <strong>Zweck:</strong> Definiert Parameter f√ºr die Agenten des Algorithmus.
            </p>
            <ul>
                <li><code>count</code>: Anzahl der Agenten (z.B. 64).</li>
                <li><code>step</code>: Schrittgr√∂√üe der Agenten.</li>
                <li><code>curiosity</code>: Neugier-Faktor der Agenten.</li>
                <li><code>momentum</code>: Impuls-Faktor.</li>
                <li><code>deposit_sigma</code>: Breite der Feldablage durch Agenten.</li>
            </ul>
        </li>
        <li>
            <code>HPIOConfig</code>:
            <p>
                <strong>Zweck:</strong> Die Hauptkonfigurationsklasse, die alle Parameter f√ºr einen HPIO-Lauf zusammenf√ºhrt.
            </p>
            <ul>
                <li><code>objective</code>: Die zu optimierende Zielfunktion (z.B. <code>rastrigin_fn</code>, <code>ackley_fn</code>, <code>himmelblau_fn</code>).</li>
                <li><code>algorithm</code>: Der zu verwendende Optimierungsalgorithmus (Standard: HPIO).</li>
                <li><code>iters</code>: Anzahl der Iterationen.</li>
                <li><code>seed</code>: Zufalls-Seed f√ºr Reproduzierbarkeit.</li>
                <li><code>anneal_step_from</code>, <code>anneal_curiosity_to</code>: Annealing-Faktoren f√ºr Schrittgr√∂√üe und Neugier.</li>
                <li><code>early_patience</code>, <code>early_tol</code>: Kriterien f√ºr den Fr√ºhabbruch.</li>
            </ul>
        </li>
        <li>
            Zielfunktionen (z.B. <code>rastrigin_fn</code>, <code>ackley_fn</code>, <code>himmelblau_fn</code>):
            <p>
                <strong>Zweck:</strong> Bekannte mathematische Funktionen, die als Benchmarks f√ºr die Optimierungsleistung dienen.
            </p>
        </li>
        <li>
            Hilfsfunktionen (z.B. <code>_gaussian_kernel_1d</code>, <code>_stamp_gaussian</code>):
            <p>
                <strong>Zweck:</strong> Sorgen f√ºr die mathematische Pr√§zision bei der Feldinteraktion und anderen Berechnungen.
            </p>
        </li>
    </ul>

    <h3>2. Die B√ºhne f√ºr die Visualisierung: <code>hpio_record.py</code></h3>
    <p>
        Dieses Modul ist f√ºr die Aufzeichnung und Visualisierung des HPIO-Optimierungsprozesses zust√§ndig. Es erm√∂glicht die Erstellung von Videos, die jeden Schritt des Algorithmus festhalten. Es wurde bewusst auf Komposition statt Vererbung gesetzt, um die Unabh√§ngigkeit und die Verwendung der aktuellsten HPIO-Kernversion zu gew√§hrleisten.
    </p>
    <h4>Funktionale Bausteine:</h4>
    <ul>
        <li>
            <code>load_local_hpio()</code>:
            <p>
                <strong>Zweck:</strong> Stellt sicher, dass die korrekte <code>hpio.py</code> dynamisch geladen wird.
            </p>
        </li>
        <li>
            <code>VideoWriter</code>:
            <p>
                <strong>Zweck:</strong> Eine flexible Klasse zum Schreiben von Videodateien, bevorzugt FFmpeg (√ºber Matplotlib), alternativ OpenCV. Unterst√ºtzt den Export in MP4/MKV.
            </p>
        </li>
        <li>
            <code>HPIORecorder</code>:
            <p>
                <strong>Zweck:</strong> Verwaltet die Visualisierung in einer Matplotlib-Figur, typischerweise mit einer Heatmap des Feldes links und einer Konsole/Logs rechts.
            </p>
        </li>
        <li>
            <code>RecordingRunner</code>:
            <p>
                <strong>Zweck:</strong> Kapselt die HPIO-Optimierungsschleife und integriert den Recorder, sammelt Daten und rendert Frames f√ºr die Videoerstellung.
            </p>
        </li>
    </ul>

    <h3>3. Das interaktive Kontrollzentrum: Die Streamlit‚ÄëApp (<code>streamlit_app.py</code>)</h3>
    <p>
        Die Streamlit-Anwendung dient als interaktives Kontrollzentrum f√ºr das HPIO-System. Sie bietet eine benutzerfreundliche Oberfl√§che, um den Optimierungsalgorithmus zu konfigurieren, zu starten, zu steuern und die Ergebnisse zu visualisieren.
    </p>
    <h4>Wichtige Funktionen und Bereiche:</h4>
    <ul>
        <li>
            <strong>Installation & Start:</strong>
            <p>Anleitung zur Installation der Voraussetzungen (<code>numpy</code>, <code>pandas</code>, <code>streamlit</code>, <code>matplotlib</code>, <code>imageio</code>, optional <code>pyopencl</code>, <code>opencv-python</code>) und zum Starten der Anwendung.</p>
        </li>
        <li>
            <strong>GUI im √úberblick:</strong>
            <p>Beschreibung der allgemeinen Struktur der App mit Navigation, Hauptbereich, Selectboxen, Slidern, Checkboxen und Buttons.</p>
        </li>
        <li>
            <strong>HPIO starten & steuern (‚ÄûStart / Run‚Äú):</strong>
            <p>Erm√∂glicht die Auswahl der Zielfunktion, das Setzen von Seed und Iterationen, die Aktivierung der GPU (PyOpenCL) und die Konfiguration von Visualisierungseinstellungen (<code>viz_frequency</code>, <code>overlay</code>, <code>trail_length</code>). Bietet Kontrollen wie *Start*, *Pause/Weiter*, *Stop*, *Schritt vor* und *Reset*. Eine Besonderheit ist die Live-Parameteranpassung w√§hrend des Betriebs.</p>
        </li>
        <li>
            <strong>Parameter (‚ÄûParameter‚Äú):</strong>
            <p>Ein Bereich zur detaillierten Konfiguration von Feld-, Agenten- und Ablageparametern, Annealing-Einstellungen sowie Fr√ºhabbruch- und Polish-Kriterien. √Ñnderungen werden √ºber ‚Äû√úbernehmen‚Äú best√§tigt.</p>
        </li>
        <li>
            <strong>Algorithmus‚ÄëBibliothek (‚ÄûAlgorithmen‚Äú):</strong>
            <p>Bietet Vergleichsm√∂glichkeiten mit klassischen Optimierungsalgorithmen wie Differential Evolution (DE), Particle Swarm Optimization (PSO) und Genetischen Algorithmen (GA), jeweils mit eigenen Parametern und Visualisierungen.</p>
        </li>
        <li>
            <strong>Presets (‚ÄûPresets‚Äú):</strong>
            <p>Funktionalit√§t zum Laden, Speichern und Hochladen von Konfigurations-Presets. Zeigt Unterschiede zur aktuellen Konfiguration an und kann CLI-Befehle f√ºr <code>hpio_record.py</code> generieren.</p>
        </li>
        <li>
            <strong>Aufnahme & Export (‚ÄûAufnahme / Export‚Äú):</strong>
            <p>Einstellungen f√ºr Videoaufnahmen (Dateiname, Format, FPS, Encoder-Preset) und Exportoptionen f√ºr Konfiguration (JSON), beste Trajektorie (CSV), Metriken (CSV/JSON), Heatmap-Snapshots (ZIP) und Logs (TXT).</p>
        </li>
        <li>
            <strong>Experimente (‚ÄûExperimente‚Äú):</strong>
            <p>Erm√∂glicht Batch-Runs und Parameterstudien wie Seeds-Sweeps, Preset-Vergleiche und Parameter-Rasterstudien, mit Exportm√∂glichkeiten der Ergebnisse als JSON.</p>
        </li>
        <li>
            <strong>Hilfe & Dokumentation (‚ÄûHilfe‚Äú):</strong>
            <p>Bietet eine Einf√ºhrung in HPIO, ein Parameter-Glossar, Troubleshooting-Tipps und Performance-Hinweise.</p>
        </li>
    </ul>

    <h3>4. Die architektonische Vision: Fundament moderner Webanwendungen</h3>
    <p>
        Dieser Abschnitt beschreibt die zugrunde liegenden architektonischen Prinzipien, die die Designentscheidungen f√ºr das HPIO Control Center leiten, basierend auf einer Schichtenarchitektur.
    </p>
    <h4>Konzepte:</h4>
    <ul>
        <li>
            <strong>Executive Summary:</strong>
            <p>Betont die Vorteile einer schichtbasierten Architektur (Frontend/Backend) f√ºr Robustheit, Skalierbarkeit und Wartbarkeit, mit klaren Verantwortlichkeiten f√ºr Pr√§sentation, Gesch√§ftslogik und Datenzugriff.</p>
        </li>
        <li>
            <strong>Problemstellung:</strong>
            <p>Adressiert die Herausforderungen monolithischer Ans√§tze und das Ziel, Komplexit√§t zu reduzieren, die Entwicklung zu beschleunigen und die Zukunftsf√§higkeit zu sichern.</p>
        </li>
        <li>
            <strong>Systemarchitektur & Funktionsweise:</strong>
            <p>Detaillierte Beschreibung der Frontend- und Backend-Architekturkomponenten und ihres Zusammenspiels.</p>
            <ul>
                <li>
                    <strong>Frontend‚ÄëArchitektur:</strong>
                    <ul>
                        <li><code>App</code>: Einstiegspunkt.</li>
                        <li><code>Pages</code>: Routen/Ansichten.</li>
                        <li><code>Components</code>: Wiederverwendbare UI-Bausteine.</li>
                        <li><code>ApiService</code>: Abstrahierte Datenkommunikation.</li>
                    </ul>
                </li>
                <li>
                    <strong>Backend‚ÄëArchitektur:</strong>
                    <ul>
                        <li><code>Controller</code>: Validiert Anfragen, delegiert an Services.</li>
                        <li><code>Service</code>: Enth√§lt Gesch√§ftslogik & Orchestrierung.</li>
                        <li><code>Repository</code>: Abstrahierter Datenzugriff.</li>
                        <li><code>Model</code>: Dom√§nenobjekte / DTOs.</li>
                        <li><code>Database</code>: Persistente Speicherung.</li>
                    </ul>
                </li>
                <li>
                    <strong>Datenfluss:</strong>
                    <p>Beschreibt den Kommunikationsweg von Frontend √ºber ApiService, Controller, Service, Repository bis zur Database, wobei Model als gemeinsame Sprache dient.</p>
                </li>
            </ul>
        </li>
        <li>
            <strong>Architekturdiagramm:</strong>
            <p>Ein Mermaid-Klassendiagramm visualisiert die konzeptionelle Schichtenarchitektur und die Abh√§ngigkeiten zwischen den Komponenten.</p>
        </li>
        <li>
            <strong>Evaluation & Testergebnisse:</strong>
            <p>Hervorhebung der Vorteile klarer Schichten bez√ºglich Fehleranf√§lligkeit, Testbarkeit, Skalierbarkeit, geringer Latenz und hoher Durchsatz.</p>
        </li>
        <li>
            <strong>Vergleich mit anderen Tools:</strong>
            <p>Betont die Vorteile gegen√ºber monolithischen Ans√§tzen: Modularit√§t, unabh√§ngige Skalierbarkeit, bessere Wartbarkeit und Technologieflexibilit√§t.</p>
        </li>
        <li>
            <strong>Kernkonzepte & Innovationen:</strong>
            <p>Anwendung bew√§hrter Prinzipien wie Layered Architecture, Repository-Pattern, Model-Driven Design und API-First.</p>
        </li>
        <li>
            <strong>Ausblick:</strong>
            <p>Perspektiven f√ºr zuk√ºnftige Entwicklungen wie Microservices-Migration, Event-Driven Architecture, erweiterte Sicherheit, Cloud-Native-Optimierung und st√§rkere KI/ML-Integration.</p>
        </li>
    </ul>

    <h3>5. Fazit</h3>
    <p>
        Zusammenfassung der Kernbotschaft, dass das HPIO Control Center eine Verschmelzung von algorithmischer Innovation und solider Software-Architektur darstellt, mit dem Ziel, leistungsf√§hige, verst√§ndliche, wartbare und zukunftssichere Werkzeuge zu schaffen.
    </p>

    <h3>Quellen</h3>
    <ul>
        <li>Mermaid.js (Diagramme): <a href="https://mermaid.js.org/">https://mermaid.js.org/</a></li>
        <li><em>Design Patterns: Elements of Reusable Object‚ÄëOriented Software</em> (Gang of Four)</li>
        <li><em>Domain‚ÄëDriven Design</em> (Eric Evans)</li>
        <li><em>Clean Architecture</em> (Robert C. Martin)</li>
    </ul>

    <h3>Glossar</h3>
    <ul>
        <li><strong>API (Application Programming Interface)</strong> ‚Äì Schnittstelle, √ºber die Softwarekomponenten interagieren.</li>
        <li><strong>Backend</strong> ‚Äì Serverseitiger Teil f√ºr Datenverarbeitung, Gesch√§ftslogik und Datenbankzugriff.</li>
        <li><strong>Controller</strong> ‚Äì Nimmt HTTP‚ÄëAnfragen entgegen und delegiert an Services.</li>
        <li><strong>Frontend</strong> ‚Äì Clientseitige Benutzeroberfl√§che.</li>
        <li><strong>HTTP (Hypertext Transfer Protocol)</strong> ‚Äì Prim√§res Kommunikationsprotokoll des Web.</li>
        <li><strong>Model</strong> ‚Äì Datenstrukturen/Entit√§ten der Dom√§ne.</li>
        <li><strong>ORM (Object‚ÄëRelational Mapper)</strong> ‚Äì Bindeglied zwischen Objekten und relationalen Datenbanken.</li>
        <li><strong>Repository‚ÄëMuster</strong> ‚Äì Abstrahiert Datenzugriff, entkoppelt Gesch√§ftslogik von Persistenzdetails.</li>
        <li><strong>Service</strong> ‚Äì Enth√§lt Kern‚ÄëGesch√§ftslogik.</li>
        <li><strong>UI (User Interface)</strong> ‚Äì Oberfl√§che zur Interaktion.</li>
        <li><strong>UX (User Experience)</strong> ‚Äì Gesamterlebnis der Benutzung.</li>
    </ul>
</section>
<section id="HPIO-main/manual.md">
    <h2>HPIO-main/manual.md</h2>

    <p>
        Diese Datei dient als umfassendes Benutzerhandbuch f√ºr das "HPIO Control Center". Es beschreibt die Installation, die Benutzeroberfl√§che, die Funktionsweise des Hybrid Pheromone Inspired Optimizer (HPIO) und anderer Vergleichsalgorithmen sowie detaillierte Anleitungen zur Konfiguration, Ausf√ºhrung und Analyse von Optimierungsl√§ufen.
    </p>

    <h3>Benutzerhandbuch: HPIO Control Center</h3>
    <p>
        Das HPIO Control Center ist eine leistungsstarke Software zur Optimierung komplexer Probleme mittels verschiedener Algorithmen. Es implementiert einen Hybrid Pheromone Inspired Optimizer (HPIO), der von der Natur inspiriert ist, um optimale L√∂sungen f√ºr mathematische Zielfunktionen zu finden. Die Anwendung bietet auch Vergleichsm√∂glichkeiten mit klassischen Optimierungsalgorithmen wie Differential Evolution, Partikel-Schwarm-Optimierung und Genetischen Algorithmen. Es l√∂st das Problem der Suche nach globalen Minima von mehrdimensionalen Funktionen und bietet eine interaktive Oberfl√§che zur Visualisierung und Feinabstimmung der Algorithmusparameter.
    </p>

    <h4>1. Erste Schritte: Installation und Start</h4>
    <p>
        Dieser Abschnitt beschreibt die notwendigen Schritte zur Installation der Anwendung und ihrer Abh√§ngigkeiten sowie zum Starten des HPIO Control Centers.
    </p>
    <ul>
        <li>
            <h5>1.1 Voraussetzungen</h5>
            <p>Erfordert Python 3.8+ und den Paketmanager <code>pip</code>.</p>
        </li>
        <li>
            <h5>1.2 Installation der Abh√§ngigkeiten</h5>
            <p>Anleitung zur Installation der Kernbibliotheken (<code>numpy</code>, <code>pandas</code>, <code>streamlit</code>, <code>matplotlib</code>, <code>imageio</code>) und optionaler Bibliotheken f√ºr GPU-Beschleunigung (<code>pyopencl</code>) und erweiterte Videoexport-Funktionen (<code>opencv-python</code>).</p>
            <p><code>pip install numpy pandas streamlit matplotlib imageio</code></p>
            <p><code>pip install pyopencl opencv-python</code></p>
        </li>
        <li>
            <h5>1.3 Starten der Anwendung</h5>
            <p>Anleitung zum Starten der Streamlit-Anwendung √ºber das Terminal.</p>
            <p><code>streamlit run streamlit_app.py</code></p>
        </li>
    </ul>

    <h4>2. Die Benutzeroberfl√§che (GUI) im √úberblick</h4>
    <p>
        Eine Beschreibung der allgemeinen Struktur der Benutzeroberfl√§che, einschlie√ülich Seitenleiste, Hauptbereich und h√§ufig verwendeter GUI-Elemente.
    </p>
    <ul>
        <li>
            <h5>2.1 Seitenleiste</h5>
            <p>Enth√§lt die Hauptnavigation und seitenabh√§ngige Steuerelemente.</p>
        </li>
        <li>
            <h5>2.2 Hauptbereich</h5>
            <p>Zeigt den Inhalt der aktuell ausgew√§hlten Seite an, oft unterteilt in Abschnitte.</p>
        </li>
        <li>
            <h5>2.3 Allgemeine GUI-Elemente</h5>
            <p>Erl√§uterung von Elementen wie Selectboxen, Number Inputs, Slider, Checkboxes, Buttons, Text Inputs, Formularen, Diagrammen und Bildern.</p>
        </li>
    </ul>

    <h4>3. HPIO-Optimierung starten und steuern ('Start / Run')</h4>
    <p>
        Dieser Abschnitt ist das Herzst√ºck der Anwendung und erkl√§rt, wie die HPIO-Optimierung konfiguriert, gestartet und live verfolgt werden kann.
    </p>
    <ul>
        <li>
            <h5>3.1 Basis-Setup</h5>
            <p>Konfiguration von Zielfunktion (<code>rastrigin</code>, <code>ackley</code>, <code>himmelblau</code>) und Aktivierung der GPU-Beschleunigung (PyOpenCL).</p>
        </li>
        <li>
            <h5>3.2 Seed & Iterationen</h5>
            <p>Einstellung des Zufalls-Seeds f√ºr reproduzierbare Ergebnisse und der maximalen Anzahl von Optimierungsschritten.</p>
        </li>
        <li>
            <h5>3.3 Visualisierung</h5>
            <p>Parameter f√ºr die Live-Visualisierung, wie <code>Viz-Frequenz</code>, <code>Overlay</code> und <code>Traill√§nge</code>.</p>
        </li>
        <li>
            <h5>3.4 Run-Kontrollen</h5>
            <p>Beschreibung der Buttons zum Steuern des Optimierungsprozesses: <code>Start</code>, <code>Pause / Weiter</code>, <code>Stop</code>, <code>Schritt vor</code>, <code>Reset</code>, <code>Reset + neuer Seed</code>.</p>
        </li>
        <li>
            <h5>3.5 Live-Parameteranpassung</h5>
            <p>M√∂glichkeit zur Anpassung wichtiger Agentenparameter w√§hrend eines laufenden Optimierungsprozesses, z.B. <code>Agent step</code>, <code>Curiosity</code>, <code>Momentum</code>, <code>deposit_sigma</code>, <code>coherence_gain</code>, <code>w_intensity</code>, <code>w_phase</code>, <code>phase_span_pi</code>.</p>
        </li>
        <li>
            <h5>3.6 Hauptanzeige</h5>
            <p>Beschreibung der im Hauptbereich angezeigten Informationen: <code>Heatmap &amp; Agents</code>, <code>Parameter Snapshot</code>, <code>Status</code>, <code>Konsole</code> und <code>Live-Metriken</code>.</p>
        </li>
    </ul>

    <h4>4. Detaillierte Funktionsbeschreibung: Parameter ('Parameter')</h4>
    <p>
        Diese Seite erm√∂glicht die detaillierte Konfiguration aller HPIO-Algorithmusparameter.
    </p>
    <ul>
        <li>
            <h5>4.1 Feldparameter</h5>
            <p>Parameter, die das Pheromonfeld beeinflussen: <code>Grid Breite / Grid H√∂he</code>, <code>relax_alpha</code>, <code>evap</code>, <code>kernel_sigma</code>.</p>
        </li>
        <li>
            <h5>4.2 Agenten &amp; Ablageparameter</h5>
            <p>Parameter, die das Verhalten der Agenten und ihre Interaktion mit dem Feld steuern: <code>count</code>, <code>step</code>, <code>curiosity</code>, <code>momentum</code>, <code>deposit_sigma</code>, <code>coherence_gain</code>, <code>w_intensity</code>, <code>w_phase</code>, <code>phase_span_pi</code>.</p>
        </li>
        <li>
            <h5>4.3 Annealing-Parameter</h5>
            <p>Parameter zur dynamischen Anpassung von <code>step</code> und <code>curiosity</code> √ºber die Laufzeit: <code>anneal_step_from / anneal_step_to</code>, <code>anneal_curiosity_from / anneal_curiosity_to</code>.</p>
        </li>
        <li>
            <h5>4.4 Fr√ºhabbruch &amp; Polish</h5>
            <p>Parameter f√ºr den vorzeitigen Abbruch und die lokale Nachbesserung: <code>early_patience</code>, <code>early_tol</code>, <code>polish_h</code>.</p>
        </li>
        <li>
            <h5>4.5 √Ñnderungen anwenden</h5>
            <p>Anleitung zum Speichern von Parameter√§nderungen und zum Zur√ºcksetzen auf Standardwerte oder Presets.</p>
        </li>
    </ul>

    <h4>5. Algorithmus-Bibliothek ('Algorithmen')</h4>
    <p>
        Auf dieser Seite k√∂nnen klassische Optimierungsalgorithmen ausgef√ºhrt und deren Konvergenzmetriken mit HPIO verglichen werden.
    </p>
    <ul>
        <li>
            <h5>5.1 Algorithmus ausw√§hlen</h5>
            <p>Auswahl zwischen <code>Differential Evolution</code>, <code>Particle Swarm Optimization</code> und <code>Genetischer Algorithmus</code>.</p>
        </li>
        <li>
            <h5>5.2 Algorithmus-Parameter</h5>
            <p>Spezifische Parameter f√ºr jeden Algorithmus, wie <code>Seed</code>, <code>Iterationen</code>, <code>Population</code>, <code>Mutation</code>, <code>Crossover</code>, <code>Schwarmgr√∂√üe</code>, <code>Tr√§gheit</code>, <code>Kognitiv</code>, <code>Sozial</code>, <code>Tournament-k</code>.</p>
        </li>
        <li>
            <h5>5.3 Algorithmus starten</h5>
            <p>Button zum Starten des ausgew√§hlten Algorithmus.</p>
        </li>
        <li>
            <h5>5.4 Ergebnisse</h5>
            <p>Anzeige von <code>Bestwert</code>, <code>Beste Position</code>, Liniendiagrammen, Fl√§chendiagrammen, Export-Buttons und einem JSON-Snapshot der Konfiguration und Ergebnisse.</p>
        </li>
    </ul>

    <h4>6. Presets ('Presets')</h4>
    <p>
        Diese Seite bietet eine einfache M√∂glichkeit, vordefinierte oder eigene Konfigurationen zu laden, zu speichern und zu verwalten.
    </p>
    <ul>
        <li>
            <h5>6.1 Preset w√§hlen</h5>
            <p>Auswahl aus einer Liste von vordefinierten oder eigenen Presets.</p>
        </li>
        <li>
            <h5>6.2 Preset anwenden</h5>
            <p>√úbertr√§gt die Parameter des ausgew√§hlten Presets auf die aktuelle HPIO-Konfiguration.</p>
        </li>
        <li>
            <h5>6.3 Preset speichern (JSON)</h5>
            <p>L√§dt die aktuelle HPIO-Konfiguration als JSON-Datei herunter.</p>
        </li>
        <li>
            <h5>6.4 Preset laden (JSON)</h5>
            <p>Erm√∂glicht das Hochladen einer zuvor gespeicherten JSON-Konfigurationsdatei.</p>
        </li>
        <li>
            <h5>6.5 Diff zur aktuellen Konfiguration</h5>
            <p>Zeigt Unterschiede zwischen der aktuellen Konfiguration und dem ausgew√§hlten Preset.</p>
        </li>
        <li>
            <h5>6.6 Copy as CLI</h5>
            <p>Generiert einen Befehlszeilen-Einzeiler zum Starten des <code>hpio_record.py</code>-Skripts mit der aktuellen Konfiguration.</p>
        </li>
    </ul>

    <h4>7. Aufnahme &amp; Export ('Aufnahme / Export')</h4>
    <p>
        Auf dieser Seite k√∂nnen der Optimierungsprozess als Video aufgezeichnet und verschiedene Datenartefakte exportiert werden.
    </p>
    <ul>
        <li>
            <h5>7.1 Video-Einstellungen</h5>
            <p>Konfiguration von <code>Dateiname</code>, <code>Format</code>, <code>FPS</code>, <code>Viz-Frequenz (Frames)</code>, <code>Overlay √ºbernehmen</code>, <code>Encoder-Preset</code> und <code>CRF</code> f√ºr die Videoaufnahme.</p>
        </li>
        <li>
            <h5>7.2 Videoaufnahme steuern</h5>
            <p>Buttons zum Starten und Stoppen der Aufnahme, mit Fortschrittsanzeige.</p>
        </li>
        <li>
            <h5>7.3 Artefakte exportieren</h5>
            <p>M√∂glichkeit zum Download von <code>Config (JSON)</code>, <code>Best-Trajectory (CSV)</code>, <code>Metriken (CSV/JSON)</code>, <code>Heatmap-Snapshots (ZIP)</code> und <code>Log (TXT)</code>.</p>
        </li>
        <li>
            <h5>7.4 Hinweise</h5>
            <p>Zus√§tzliche Informationen zur Videokompatibilit√§t und Encoder-Einstellungen.</p>
        </li>
    </ul>

    <h4>8. Experimente ('Experimente')</h4>
    <p>
        Die Seite 'Experimente' erm√∂glicht das Durchf√ºhren von Batch-L√§ufen und Parameterstudien.
    </p>
    <ul>
        <li>
            <h5>8.1 Seeds-Sweep</h5>
            <p>Durchf√ºhrung mehrerer L√§ufe mit verschiedenen Seeds, um die Robustheit zu testen.</p>
        </li>
        <li>
            <h5>8.2 Preset-Vergleich</h5>
            <p>Vergleich mehrerer Presets √ºber wiederholte L√§ufe mit zuf√§lligen Seeds.</p>
        </li>
        <li>
            <h5>8.3 Parameter-Raster</h5>
            <p>Systematisches Testen verschiedener Parameterkombinationen durch Angabe von Parameter-Keys und Werten oder Hochladen einer CSV-Datei.</p>
        </li>
        <li>
            <h5>8.4 Export &amp; Visualisierung</h5>
            <p>M√∂glichkeit zum Herunterladen der kombinierten Experimentierergebnisse als JSON-Datei.</p>
        </li>
    </ul>

    <h4>9. Hilfe &amp; Dokumentation ('Hilfe')</h4>
    <p>
        Die Seite 'Hilfe' bietet eine Zusammenfassung der wichtigsten Informationen √ºber HPIO.
    </p>
    <ul>
        <li>
            <h5>9.1 Was ist HPIO?</h5>
            <p>Eine kurze Einf√ºhrung in den Hybrid Pheromone Inspired Optimizer.</p>
        </li>
        <li>
            <h5>9.2 Parameter-Glossar</h5>
            <p>Eine Liste der wichtigsten HPIO-Parameter mit kurzen Erkl√§rungen ihrer Funktion, z.B. <code>relax_alpha</code>, <code>evap</code>, <code>kernel_sigma</code>, <code>step / curiosity / momentum</code>, <code>deposit_sigma</code>, <code>coherence_gain</code>, <code>w_intensity / w_phase / phase_span_pi</code>, <code>anneal_*</code>, <code>early_patience / early_tol</code>, <code>polish_h</code>.</p>
        </li>
        <li>
            <h5>9.3 Troubleshooting</h5>
            <p>Antworten auf h√§ufige Probleme und Empfehlungen zur Parameteranpassung f√ºr spezifische Zielfunktionen.</p>
        </li>
        <li>
            <h5>9.4 Performance-Tipps</h5>
            <p>Empfehlungen zur Verbesserung der Anwendungsleistung, z.B. Gridgr√∂√üe, Viz-Frequenz, GPU-Beschleunigung.</p>
        </li>
        <li>
            <h5>9.5 Kompatibilit√§t &amp; Tools</h5>
            <p>Informationen zu ben√∂tigten Bibliotheken f√ºr den Videoexport und zur Generierung von CLI-Befehlen.</p>
        </li>
    </ul>
</section>
<section id="HPIO-main/streamlit_app.py">
    <h2>HPIO-main/streamlit_app.py</h2>
    <p>
        Diese Datei implementiert eine interaktive Streamlit-Anwendung zur Experimentation und Visualisierung des HPIO-Algorithmus (Hybrid Pheromone Inspired Optimizer). Sie bietet eine Benutzeroberfl√§che zur Konfiguration von HPIO-Parametern, zur Durchf√ºhrung von Optimierungsl√§ufen, zur Visualisierung der Agentenbewegung und des Feldes sowie zum Vergleich mit anderen Optimierungsalgorithmen.
    </p>

    <h3>Klassen</h3>

    <div class="component-documentation">
        <h3 id="StepResult"><code>StepResult</code></h3>
        <p>
            Eine Datenklasse, die die Ergebnisse eines einzelnen Iterationsschritts des HPIO-Optimierers kapselt.
        </p>
        <h4>Attribute:</h4>
        <ul>
            <li><code>iteration</code> (int): Die aktuelle Iterationsnummer.</li>
            <li><code>best_val</code> (float): Der beste gefundene Wert in dieser Iteration.</li>
            <li><code>best_pos</code> (np.ndarray): Die Position des besten gefundenen Wertes.</li>
            <li><code>delta_best</code> (float): Die √Ñnderung des besten Wertes seit der letzten Iteration.</li>
            <li><code>field_phi</code> (np.ndarray): Eine Kopie des aktuellen Feldes (Phi-Werte).</li>
            <li><code>agents_grid</code> (np.ndarray): Die Positionen der Agenten im Grid-Koordinatensystem.</li>
            <li><code>agents_world</code> (np.ndarray): Die Positionen der Agenten im Welt-Koordinatensystem.</li>
            <li><code>elapsed</code> (float): Die f√ºr diesen Schritt ben√∂tigte Zeit in Sekunden.</li>
            <li><code>total_time</code> (float): Die kumulierte Gesamtzeit seit Beginn des Laufs.</li>
            <li><code>early_stop_triggered</code> (bool): Gibt an, ob der Fr√ºhabbruch in diesem Schritt ausgel√∂st wurde.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="HPIOController"><code>HPIOController</code></h3>
        <p>
            Verwaltet den Zustand und die Ausf√ºhrung eines HPIO-Optimierungslaufs.
            Diese Klasse initialisiert den HPIO-Optimierer und f√ºhrt Iterationsschritte aus,
            wobei sie den Fortschritt, die besten Werte und die Agentenpositionen verfolgt.
        </p>
        <h4>Attribute:</h4>
        <ul>
            <li><code>cfg</code> (HPIOConfig): Die Konfiguration des HPIO-Optimierers.</li>
            <li><code>optimizer</code> (HPIO): Die Instanz des HPIO-Optimierers (initialisiert in <code>__post_init__</code>).</li>
            <li><code>iteration</code> (int): Die aktuelle Iterationsnummer.</li>
            <li><code>no_improve</code> (int): Z√§hler f√ºr Iterationen ohne signifikante Verbesserung.</li>
            <li><code>last_best</code> (float): Der beste Wert der vorherigen Iteration.</li>
            <li><code>start_ts</code> (float): Zeitstempel des Startzeitpunkts des Laufs.</li>
            <li><code>total_time</code> (float): Die kumulierte Gesamtzeit des Laufs.</li>
            <li><code>best_history</code> (list[tuple[int, float, np.ndarray]]): Eine Historie der besten Werte und Positionen pro Iteration.</li>
        </ul>
        <h4>Methoden:</h4>
        <ul>
            <li>
                <h4 id="HPIOController.__post_init__"><code>__post_init__() -> None</code></h4>
                <p>
                    Initialisiert den HPIO-Optimierer basierend auf der Konfiguration und setzt den Startzustand.
                </p>
            </li>
            <li>
                <h4 id="HPIOController.step"><code>step() -> Optional[StepResult]</code></h4>
                <p>
                    F√ºhrt einen einzelnen Iterationsschritt des HPIO-Optimierers aus.
                    Berechnet die Agentenbewegung, Feldaktualisierung und pr√ºft auf Fr√ºhabbruch.
                </p>
                <h4>R√ºckgabewert:</h4>
                <ul>
                    <li><code>Optional[StepResult]</code>: Ein <code>StepResult</code>-Objekt, das die Ergebnisse des Schritts enth√§lt, oder <code>None</code>, wenn die maximale Iterationszahl erreicht ist.</li>
                </ul>
            </li>
            <li>
                <h4 id="HPIOController.reset"><code>reset(keep_seed: bool = True) -> None</code></h4>
                <p>
                    Setzt den Optimierer und den Controller auf den Anfangszustand zur√ºck.
                </p>
                <h4>Parameter:</h4>
                <ul>
                    <li><code>keep_seed</code> (bool): Wenn <code>True</code>, wird der aktuelle Seed beibehalten; andernfalls wird ein neuer Zufalls-Seed generiert.</li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="AppState"><code>AppState</code></h3>
        <p>
            Eine Datenklasse, die den gesamten Zustand der Streamlit-Anwendung speichert.
            Sie wird in der Streamlit-Session verwaltet, um den Zustand √ºber Reruns hinweg zu erhalten.
        </p>
        <h4>Attribute:</h4>
        <ul>
            <li><code>cfg</code> (HPIOConfig): Die aktuelle HPIO-Konfiguration.</li>
            <li><code>controller</code> (Optional[HPIOController]): Die Instanz des HPIO-Controllers, falls ein Lauf aktiv ist.</li>
            <li><code>running</code> (bool): Zeigt an, ob ein Optimierungslauf aktiv ist.</li>
            <li><code>paused</code> (bool): Zeigt an, ob der aktuelle Lauf pausiert ist.</li>
            <li><code>viz_every</code> (int): Die Frequenz, mit der Visualisierungen aktualisiert werden (jede n-te Iteration).</li>
            <li><code>trail_length</code> (int): Die L√§nge der Agentenpfade in der Visualisierung.</li>
            <li><code>overlay</code> (bool): Ob Overlay-Informationen (Iteration, Bestwert) in der Visualisierung angezeigt werden sollen.</li>
            <li><code>logs</code> (list[str]): Eine Liste von Protokollnachrichten f√ºr die Konsole.</li>
            <li><code>last_result</code> (Optional[StepResult]): Das Ergebnis des letzten ausgef√ºhrten Schritts.</li>
            <li><code>last_plot_png</code> (Optional[bytes]): Das letzte gerenderte Plot-Bild im PNG-Format.</li>
            <li><code>fps</code> (float): Die gesch√§tzte Frames per Second des Laufs.</li>
            <li><code>video_active</code> (bool): Zeigt an, ob die Videoaufnahme aktiv ist.</li>
            <li><code>video_params</code> (dict[str, Any]): Parameter f√ºr die Videoaufnahme (Dateiname, Format, FPS etc.).</li>
            <li><code>video_frames</code> (list[tuple[int, bytes]]): Eine Liste von aufgezeichneten Frames (Iteration, PNG-Bytes).</li>
            <li><code>video_limit_notified</code> (bool): Flag, um zu verhindern, dass die Frame-Limit-Warnung mehrfach angezeigt wird.</li>
            <li><code>video_last_path</code> (Optional[str]): Der Pfad zum zuletzt gespeicherten Video.</li>
            <li><code>video_progress_total</code> (int): Die erwartete Gesamtzahl der Frames f√ºr die Videoaufnahme.</li>
            <li><code>video_summary</code> (Optional[dict[str, Any]]): Eine Zusammenfassung des letzten Videoexports.</li>
            <li><code>parameter_dirty</code> (bool): Zeigt an, ob Parameter ge√§ndert wurden, die einen Reset des Controllers erfordern.</li>
            <li><code>experiment_results</code> (dict[str, Any]): Speichert Ergebnisse von Experimenten (z.B. Seeds-Sweep, Parameter-Raster).</li>
            <li><code>metrics_history</code> (list[dict[str, float]]): Eine Historie von Metriken pro Iteration.</li>
            <li><code>algorithm_runs</code> (dict[str, dict[str, Any]]): Speichert Ergebnisse von L√§ufen anderer Algorithmen.</li>
            <li><code>_trails</code> (list[list[tuple[float, float]]]): Interne Liste zur Speicherung der Agentenpfade.</li>
        </ul>
    </div>

    <h3>Funktionen</h3>

    <div class="component-documentation">
        <h3 id="gpu_available"><code>gpu_available() -> bool</code></h3>
        <p>
            Pr√ºft, ob eine GPU √ºber PyOpenCL verf√ºgbar ist.
        </p>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>bool</code>: <code>True</code>, wenn eine GPU verf√ºgbar ist, sonst <code>False</code>.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="trigger_rerun"><code>trigger_rerun() -> None</code></h3>
        <p>
            Fordert einen erneuten Durchlauf der Streamlit-App an, um den UI-Zustand zu aktualisieren.
            Verwendet entweder <code>st.rerun</code> oder <code>st.experimental_rerun</code>.
        </p>
        <h4>Fehler:</h4>
        <ul>
            <li><code>RuntimeError</code>: Wenn keine der Rerun-APIs verf√ºgbar ist.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="get_state"><code>get_state() -> AppState</code></h3>
        <p>
            Ruft den aktuellen Anwendungszustand aus der Streamlit-Session ab oder initialisiert ihn, falls nicht vorhanden.
        </p>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>AppState</code>: Die aktuelle Instanz des Anwendungszustands.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="config_to_nested"><code>config_to_nested(cfg: HPIOConfig) -> dict[str, Any]</code></h3>
        <p>
            Konvertiert ein <code>HPIOConfig</code>-Objekt in ein verschachteltes Dictionary f√ºr die Serialisierung oder Anzeige.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>cfg</code> (HPIOConfig): Die zu konvertierende HPIO-Konfiguration.</li>
        </ul>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>dict[str, Any]</code>: Die verschachtelte Dictionary-Darstellung der Konfiguration.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="nested_to_config"><code>nested_to_config(data: dict[str, Any]) -> HPIOConfig</code></h3>
        <p>
            Konvertiert ein verschachteltes Dictionary zur√ºck in ein <code>HPIOConfig</code>-Objekt.
            Wird verwendet, um Konfigurationen aus JSON oder anderen Quellen zu laden.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>data</code> (dict[str, Any]): Das verschachtelte Dictionary mit Konfigurationsdaten.</li>
        </ul>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>HPIOConfig</code>: Das erstellte HPIO-Konfigurationsobjekt.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="render_heatmap"><code>render_heatmap(phi: np.ndarray, agents_grid: np.ndarray, trails: list[list[tuple[float, float]]], iteration: int, best_val: float, overlay: bool, trail_length: int) -> bytes</code></h3>
        <p>
            Rendert eine Heatmap des Feldes (Phi-Werte) zusammen mit den Agentenpositionen und deren Pfaden.
            Erzeugt ein PNG-Bild als Bytes.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>phi</code> (np.ndarray): Die Phi-Werte des Feldes.</li>
            <li><code>agents_grid</code> (np.ndarray): Die Agentenpositionen im Grid-Koordinatensystem.</li>
            <li><code>trails</code> (list[list[tuple[float, float]]]): Die Pfade der Agenten.</li>
            <li><code>iteration</code> (int): Die aktuelle Iterationsnummer.</li>
            <li><code>best_val</code> (float): Der aktuelle beste Wert.</li>
            <li><code>overlay</code> (bool): Ob Iterations- und Bestwert-Informationen als Overlay angezeigt werden sollen.</li>
            <li><code>trail_length</code> (int): Die maximale L√§nge der angezeigten Agentenpfade.</li>
        </ul>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>bytes</code>: Das gerenderte Bild im PNG-Format.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="update_trails"><code>update_trails(trails: list[list[tuple[float, float]]], agents_grid: np.ndarray, trail_length: int) -> list[list[tuple[float, float]]]</code></h3>
        <p>
            Aktualisiert die Pfade der Agenten basierend auf ihren aktuellen Grid-Positionen.
            Stellt sicher, dass die Pfadl√§nge das angegebene Limit nicht √ºberschreitet.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>trails</code> (list[list[tuple[float, float]]]): Die bestehenden Agentenpfade.</li>
            <li><code>agents_grid</code> (np.ndarray): Die aktuellen Agentenpositionen im Grid-Koordinatensystem.</li>
            <li><code>trail_length</code> (int): Die maximale L√§nge der Pfade.</li>
        </ul>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>list[list[tuple[float, float]]]</code>: Die aktualisierten Agentenpfade.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="append_log"><code>append_log(state: AppState, message: str) -> None</code></h3>
        <p>
            F√ºgt eine Nachricht zum Konsolenprotokoll des Anwendungszustands hinzu.
            Begrenzt die Protokollgr√∂√üe auf 5000 Eintr√§ge.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>state</code> (AppState): Der aktuelle Anwendungszustand.</li>
            <li><code>message</code> (str): Die hinzuzuf√ºgende Protokollnachricht.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="ensure_controller"><code>ensure_controller(state: AppState) -> None</code></h3>
        <p>
            Stellt sicher, dass der HPIO-Controller initialisiert ist.
            Wird aufgerufen, wenn der Controller <code>None</code> ist oder Parameter ge√§ndert wurden.
            Setzt den Zustand f√ºr einen neuen Lauf zur√ºck.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>state</code> (AppState): Der aktuelle Anwendungszustand.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="ensure_video_defaults"><code>ensure_video_defaults(state: AppState) -> None</code></h3>
        <p>
            Stellt sicher, dass die Video-Parameter im Anwendungszustand Standardwerte haben,
            falls sie noch nicht gesetzt sind.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>state</code> (AppState): Der aktuelle Anwendungszustand.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="compute_expected_video_frames"><code>compute_expected_video_frames(state: AppState) -> int</code></h3>
        <p>
            Berechnet die erwartete Gesamtzahl der Frames f√ºr eine Videoaufnahme basierend auf der
            Anzahl der Iterationen und der Visualisierungsfrequenz.
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>state</code> (AppState): Der aktuelle Anwendungszustand.</li>
        </ul>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>int</code>: Die erwartete Anzahl der Video-Frames.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="format_bytes"><code>format_bytes(num_bytes: int) -> str</code></h3>
        <p>
            Formatiert eine Byte-Zahl in eine lesbare Zeichenkette (z.B. "1.2 MiB").
        </p>
        <h4>Parameter:</h4>
        <ul>
            <li><code>num_bytes</code> (int): Die zu formatierende Byte-Zahl.</li>
        </ul>
        <h4>R√ºckgabewert:</h4>
        <ul>
            <li><code>str</code>: Die formatierte Zeichenkette.</li>
        </ul>
    </div>

    <div class="component-documentation">
        <h3 id="execute_step"><code>execute_step(state: AppState) -> None</code></h3>
        <p>
            F√ºhrt einen einzelnen Schritt des HPIO-Optimierers aus, aktualisiert den Anwendungszustand
            mit den Ergebnissen, protokolliert den Fortschritt und erfasst optional Frames f√ºr die Videoaufnahme.
        </p>
    </main>
</body>
</html>